<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自行脑补</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-10T10:12:48.980Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Grayson Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个1年工作经验的PHP程序员是如何被面试官虐的？</title>
    <link href="http://yoursite.com/2019/04/10/20190410/"/>
    <id>http://yoursite.com/2019/04/10/20190410/</id>
    <published>2019-04-10T09:49:35.545Z</published>
    <updated>2019-04-10T10:12:48.980Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;首先需要说明的一点，本人只是一个毕业一年，只有一年工作经验的普通PHPer，能力有限，这篇文章只是将我这几周来的感受和体验分享出来，希望能给许多像我一样，或者互联网行业的新手带来一些收获，当然哪里说的不对或不足还是希望大神们可以加以点评补充。&lt;/p&gt;
&lt;p&gt;金三银四，每年这个时候都有很多人想借此机会跳槽或者投身某个行业，目的很明确：需求更好的环境，兑现自己的价值。特别是近十年来非常火爆的互联网行业，无论是刚毕业的，敲代码敲了几年的，还是跨行进入IT行业的，都希望自己能“拿高薪，学知识，享福利”，而如今，高校扩招，IT门槛降低也导致市场太多“低技术，高目标”的幼年程序猿（我也是其中之一），再加上今年互联网寒冬，僧多粥少，想要寻求一个面试机会都不容易，更别说拿offer了。我是不甘心浪费时间在目前这家公司，具体原因不说，所以我下定决心找一份新的工作，一方面证明自己，另一方面想让自己走出舒适圈，给自己多一点挑战。&lt;/p&gt;
&lt;h2 id=&quot;狼狈的三月&quot;&gt;&lt;a href=&quot;#狼狈的三月&quot; class=&quot;headerlink&quot; title=&quot;狼狈的三月&quot;&gt;&lt;/a&gt;狼狈的三月&lt;/h2&gt;&lt;p&gt;一开始心高气傲的我，用半天时间把自己的简历整理了一遍，那时候我的简历应该还是不错的（后续文章会详细描述如何优化简历），第二天开始在Boss直聘和拉勾上开始投递简历，一开始投递的是广州地区PHP的1-3年开发岗位，虽然反馈比例不高，但还是很幸运收到几个面试邀请。接着我留了两天时间给自己复习，其实也就是在网上Google一下PHP面试题，打开十几个标签页各种面试题，这就是我所谓的“多刷题”操作，结果可想而知，看的东西很乱导致去面试那天基本忘的七七八八，有很多还只是记住一些答案，压根就没清楚，惨状见下面具体面试。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP对象深拷贝与浅拷贝</title>
    <link href="http://yoursite.com/2019/02/27/20190227/"/>
    <id>http://yoursite.com/2019/02/27/20190227/</id>
    <published>2019-02-27T03:38:19.028Z</published>
    <updated>2019-02-27T05:59:30.460Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;php对象的赋值是引用赋值，可以参考之前一篇文章&lt;a href=&quot;https://zgxxx.github.io/2018/09/16/20180916-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PHP之道–对象和引用&lt;/a&gt;;&lt;/p&gt;
&lt;p&gt;深拷贝：赋值完全复制，两个对象完全独立，其中一个对象的属性做出改变时不会影响到另一个。&lt;/p&gt;
&lt;p&gt;浅拷贝：引用赋值，相对于取了一个别名，其中一个对象属性做出修改会影响到另一个。&lt;/p&gt;
&lt;h3 id=&quot;对象的调用&quot;&gt;&lt;a href=&quot;#对象的调用&quot; class=&quot;headerlink&quot; title=&quot;对象的调用&quot;&gt;&lt;/a&gt;对象的调用&lt;/h3&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; $abc=&lt;span class=&quot;string&quot;&gt;&quot;ABC&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$b=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$c=$b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; $b-&amp;gt;abc;&lt;span class=&quot;comment&quot;&gt;//这里输出ABC&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; $c-&amp;gt;abc;&lt;span class=&quot;comment&quot;&gt;//这里输出ABC&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$b-&amp;gt;abc=&lt;span class=&quot;string&quot;&gt;&quot;DEF&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; $c-&amp;gt;abc;&lt;span class=&quot;comment&quot;&gt;//这里输出DEF&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对象赋值，浅拷贝。上列中$b=new a; $c=$b; 其实等效于$b=new a; $c=&amp;amp;$b,也就说取了另一个名字而已，指向的内存空间还是一样的。如果想要完全独立出来一个对象，互不影响，这就涉及到clone深拷贝&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Laravel关联模型字段取别名查询不出数据的处理方法</title>
    <link href="http://yoursite.com/2019/01/19/20190119/"/>
    <id>http://yoursite.com/2019/01/19/20190119/</id>
    <published>2019-01-19T05:17:35.000Z</published>
    <updated>2019-02-27T05:42:26.995Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://iocaffcdn.phphub.org/uploads/images/201901/17/28952/hB4XgG3z1D.png!large&quot; alt=&quot;file&quot;&gt;&lt;br&gt;查询这样的有父子层次关系的菜单数据，例如id=2的数据有子数据，id=3,4,5,6,16，因为后面这些数据的parent_id都是2&lt;/p&gt;
&lt;h2 id=&quot;比较笨的办法&quot;&gt;&lt;a href=&quot;#比较笨的办法&quot; class=&quot;headerlink&quot; title=&quot;比较笨的办法&quot;&gt;&lt;/a&gt;比较笨的办法&lt;/h2&gt;&lt;p&gt;先查询每一条数据，然后再遍历查询parent_id = 每一条数据的id，最后数组拼接。这种方法不仅笨，查询次数还多，完全没必要。&lt;/p&gt;
&lt;h2 id=&quot;模型自关联&quot;&gt;&lt;a href=&quot;#模型自关联&quot; class=&quot;headerlink&quot; title=&quot;模型自关联&quot;&gt;&lt;/a&gt;模型自关联&lt;/h2&gt;&lt;p&gt;laravel自带的ORM是个神器，针对这种有关系的数据，完全可以使用关系模型，既简单又实用，由于这里只有一个数据表，关系也存在于同一张表，所以可以直接使用自关联，将两个关系定义在同一个Model里面：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发初体验</title>
    <link href="http://yoursite.com/2019/01/18/20181222/"/>
    <id>http://yoursite.com/2019/01/18/20181222/</id>
    <published>2019-01-18T13:04:41.000Z</published>
    <updated>2019-01-18T13:04:41.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp; 已经有一个多月没更新博客了,这个月确实很忙。毕业以来第一次完整负责一个项目，第一次做小程序，第一次部署正式环境，第一次周六加班（我们公司确实不怎么加班哈哈），这段时间确实又让我收获颇多，起码不再像几个月前那样，一个刚毕业的人四处充满疑惑，小心翼翼的打代码，生怕给别人带来麻烦。&lt;/p&gt;
&lt;p&gt;&amp;emsp; 可能因为性格慢热，在熟悉了环境，熟悉了同事，也得到老大的认可的情况下，我开始充满信心和热情去完成我的工作，有疑问的环节依然谦虚的请教，有不满意的地方也平和的提出来。当然，我依旧还有很多地方待提高和完善，知识学习是一方面，还有一方面是自己的脾气，就比如这次小程序上线那天，小程序码识别失败，那天早上我也很着急，排查问题都搞定自己焦头烂耳，我的测试同事过来询问我还要多久才能修复，瞬间我便管不住自己的情绪，带着怒气问为什么你们测试没测出来？后面想想确实是自己的锅，小程序码本来就不能在体验版上测，因为还没发布。今后还需好好管理下自己的脾气……&lt;br&gt;下面是开发小程序的过程踩过的一些坑：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu多版本php切换</title>
    <link href="http://yoursite.com/2019/01/18/20190116/"/>
    <id>http://yoursite.com/2019/01/18/20190116/</id>
    <published>2019-01-18T13:04:31.000Z</published>
    <updated>2019-01-18T13:04:31.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近想要学习一下swoole，虽然机子上装的是php7.0，但是考虑到一些有关swoole的轮子要依赖更高版本（例如swooletw)，所以就在机子上升级了php7.2，下面是在网上搜索或者自己折腾出来的一些笔记。&lt;/p&gt;
&lt;h3 id=&quot;版本升级操作-直接从7-0升级到7-2-：&quot;&gt;&lt;a href=&quot;#版本升级操作-直接从7-0升级到7-2-：&quot; class=&quot;headerlink&quot; title=&quot;版本升级操作(直接从7.0升级到7.2)：&quot;&gt;&lt;/a&gt;版本升级操作(直接从7.0升级到7.2)：&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo add-apt-repository ppa:ondrej/php&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get upgrade php&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 拓展升级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install php7.2-mbstring&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install php7.2-gd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install php7.2-dom&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install php7.2-mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install php7.2-curl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>使用postman调试jwt开发的接口</title>
    <link href="http://yoursite.com/2018/12/22/20181108/"/>
    <id>http://yoursite.com/2018/12/22/20181108/</id>
    <published>2018-12-22T10:42:39.000Z</published>
    <updated>2018-12-22T10:42:39.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博客文章&lt;a href=&quot;https://zgxxx.github.io/2018/11/08/20181107/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zgxxx.github.io/2018/11/08/20181107/&lt;/a&gt; 介绍了laravel使用dingo+jwt开发API的几个步骤，那么在实际操作中，我们需要测试API&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$api = app(&amp;apos;Dingo\Api\Routing\Router&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$api-&amp;gt;version(&amp;apos;v1&amp;apos;, [&amp;apos;namespace&amp;apos; =&amp;gt; &amp;apos;App\Http\Controllers\V1&amp;apos;], function ($api) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;post(&amp;apos;register&amp;apos;, &amp;apos;AuthController@register&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;post(&amp;apos;login&amp;apos;, &amp;apos;AuthController@login&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;post(&amp;apos;logout&amp;apos;, &amp;apos;AuthController@logout&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;post(&amp;apos;refresh&amp;apos;, &amp;apos;AuthController@refresh&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;post(&amp;apos;me&amp;apos;, &amp;apos;AuthController@me&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;get(&amp;apos;test&amp;apos;, &amp;apos;AuthController@test&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置了这几个路由，对应的url类似这样：&lt;a href=&quot;http://www.yourweb.com/api/me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.yourweb.com/api/me&lt;/a&gt; 使用postman来调试这些API。&lt;/p&gt;
&lt;h2 id=&quot;请求API的大致流程&quot;&gt;&lt;a href=&quot;#请求API的大致流程&quot; class=&quot;headerlink&quot; title=&quot;请求API的大致流程&quot;&gt;&lt;/a&gt;请求API的大致流程&lt;/h2&gt;&lt;p&gt;我们使用jwt代替session，首先是通过登录（jwt的attempt方法验证账号密码），成功后会返回一个JWT，我们把这个字符串统一叫做token,这个token需要我们客户端保存起来，然后后面需要认证的接口就在请求头里带上这个token，后台验证正确后就会进行下一操作，如果token错误，或者过期就返回401或500错误，拒绝后面的操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前端可以保存在localStorage,小程序可以 使用wx.setStorageSync保存&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel修炼：服务容器绑定与解析</title>
    <link href="http://yoursite.com/2018/11/08/20181013/"/>
    <id>http://yoursite.com/2018/11/08/20181013/</id>
    <published>2018-11-08T12:21:37.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp; 老实说，第一次老大让我看laravel框架手册的那天早上，我是很绝望的，因为真的没接触过，对我这种渣渣来说，laravel的入门门槛确实有点高了，但还是得硬着头皮看下去（虽然到现在我还有很多没看懂，也没用过）。&lt;/p&gt;
&lt;p&gt;&amp;emsp; 后面慢慢根据公司项目的代码对laravel也慢慢熟悉起来了，但还是停留在一些表面的功能，例如依赖注入，ORM操作，用户认证这些和我项目业务逻辑相关的操作，然后对于一些架构基础的，例如服务提供器，服务容器，中间件，Redis等这些一开始就要设置好的东西，我倒是没实际操作过（因为老大一开始就做好了），所以看手册还是有点懵。&lt;/p&gt;
&lt;p&gt;&amp;emsp; 所以有空的时候逛逛论坛，搜下Google就发现许多关于laravel核心架构的介绍，以及如何使用的网站（确实看完后再去看手册就好理解多了），下面就根据一个我觉得不错的网站上面的教学来记录一下laravel核心架构的学习&lt;br&gt;网站地址：&lt;a href=&quot;https://laraweb.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://laraweb.net/&lt;/a&gt; 这是一个日本的网站，我觉得挺适合新手的，内容用浏览器翻译过来就ok了，毕竟日文直翻过来很好理解的&lt;/p&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>laravel5.5+dingo+JWT开发后台API</title>
    <link href="http://yoursite.com/2018/11/08/20181107/"/>
    <id>http://yoursite.com/2018/11/08/20181107/</id>
    <published>2018-11-08T12:21:37.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;dingo api 中文文档： &lt;a href=&quot;https://www.bookstack.cn/read/dingo-api-wiki-zh/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bookstack.cn/read/dingo-api-wiki-zh/README.md&lt;/a&gt;&lt;br&gt;Laravel中使用JWT：&lt;a href=&quot;https://laravel-china.org/articles/10885/full-use-of-jwt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://laravel-china.org/articles/10885/full-use-of-jwt&lt;/a&gt;&lt;br&gt;辅助文章：               &lt;a href=&quot;https://www.jianshu.com/p/62b0c4d75e59&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/62b0c4d75e59&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.jianshu.com/p/62b0c4d75e59&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/62b0c4d75e59&lt;/a&gt; 这篇文章基本就能搭建出环境，我使用的版本跟他一样 “dingo/api”: “2.0.0-alpha1”,”tymon/jwt-auth”: “^1.0.0-rc.1”，不知道别的版本有啥大的区别，但是网上找的其他一些文章使用的是旧的版本，jwt封装的东西路径可能不一样，可能会保错，有些文档还说要手动添加Tymon\JWTAuth\Providers\LaravelServiceProvider::class和Dingo\Api\Provider\LaravelServiceProvider::class，其实新版本不需要。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel修炼：服务提供者</title>
    <link href="http://yoursite.com/2018/10/27/20181027/"/>
    <id>http://yoursite.com/2018/10/27/20181027/</id>
    <published>2018-10-27T14:33:05.000Z</published>
    <updated>2019-01-18T13:05:07.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp; 上一篇博客文章收集了关于Laravel服务容器的相关知识（&lt;a href=&quot;https://zgxxx.github.io/2018/10/14/20181013/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;），我们知道了服务容器主要有绑定和解析两个重要功能，那么Laravel这个框架集齐了如此多功能，我们项目可能还需要另外引入一些功能包，这些绑定必须有一个统一的管理工具，统一绑定在一个地方，这个地方就是服务提供者。&lt;/p&gt;
&lt;h2 id=&quot;关于服务提供者&quot;&gt;&lt;a href=&quot;#关于服务提供者&quot; class=&quot;headerlink&quot; title=&quot;关于服务提供者&quot;&gt;&lt;/a&gt;关于服务提供者&lt;/h2&gt;&lt;p&gt;&amp;emsp; 一开始学Laravel被服务容器和服务提供者两个名称搞混了，其实现在我是这样理解：容器就是底层一个大桶， 我们需要很多材料往里面填充，而提供者就是一些管道，我们就是通过提供者往容器里面塞我们需要的东西，需要的服务。&lt;/p&gt;
&lt;p&gt;&amp;emsp; Laravel有一种机制来定义和执行每个服务的初始处理，实现初始处理的类称为&lt;strong&gt;服务提供者&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;&amp;emsp; 服务提供者，在laravel里面，其实就是一个工厂类。它最大的作用就是用来进行服务绑定。当我们需要绑定一个或多个服务的时候，可以自定义一个服务提供者，然后把服务绑定的逻辑都放在该类的实现中。在larave里面，要自定一个服务提供者非常容易，只要继承Illuminate\Support\ServiceProvider这个类即可。下面通过一个简单的自定义服务提供者来说明服务提供者的一些要点：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>假期结束</title>
    <link href="http://yoursite.com/2018/10/07/20181007/"/>
    <id>http://yoursite.com/2018/10/07/20181007/</id>
    <published>2018-10-07T13:06:54.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>JWT -- JSON Web Token</title>
    <link href="http://yoursite.com/2018/09/25/20180925/"/>
    <id>http://yoursite.com/2018/09/25/20180925/</id>
    <published>2018-09-25T10:06:18.000Z</published>
    <updated>2019-01-18T13:05:30.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;做的项目一直都是用最经典session来实现用户认证，今天老大可能在重构H5模块发现session有问题，具体问题到时我再去看看。然后老大让我了解一下JWT,没听过这个东东，也是一脸懵逼，所以自己就在网上开始搜索相关知识，下面是一些网上找到的博客文章，进行收集整理，然后再添加自己的一些见解，具体的转载地址都在下面。&lt;/p&gt;
&lt;h2 id=&quot;传统session认证流程&quot;&gt;&lt;a href=&quot;#传统session认证流程&quot; class=&quot;headerlink&quot; title=&quot;传统session认证流程&quot;&gt;&lt;/a&gt;传统session认证流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;当用户使用用户名和密码登录之后, 服务器就会生成一个 session 文件, session 文件中保存着对这个用户的授权信息,这个文件可以储存在硬盘/内存/数据库中.&lt;/li&gt;
&lt;li&gt;同时还要生成一个对应这个 session 文件的 &lt;strong&gt;sessionid&lt;/strong&gt;, 通过 sessionid 就能够找到这个 session 文件.&lt;/li&gt;
&lt;li&gt;然后将 sessionid 发送给客户端, 客户端就将 sessionid 保存起来, 保存的方式有很多种, 目前大多情况是通过 cookie 来保存 sessionid.&lt;/li&gt;
&lt;li&gt;保存之后, 当客户机以后再向服务器发送请求的时候, 请求携带上 sessionid, 这样服务器收到 sessionid 之后,自己就会在服务区上查找对应的 session 文件, 如果查找成功, 就会得到该用户的授权信息, 从而完成一次授权.&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Web知识" scheme="http://yoursite.com/tags/Web%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PHP之道-- 对象和引用</title>
    <link href="http://yoursite.com/2018/09/16/20180916-2/"/>
    <id>http://yoursite.com/2018/09/16/20180916-2/</id>
    <published>2018-09-16T15:56:23.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在PHP 中引用的意思是用不同的名字访问同一个变量内容。与在C语言中的指针不同：例如不能对引用做指针运算，引用并不是实际的内存地址&lt;/p&gt;
&lt;p&gt;PHP内核的角度：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct _zval_struct &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;zvalue_value value; // 存储变量的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;zend_uint refcount__gc; //表示引用计数 默认为：1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;zend_uchar type; // 变量具体的类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;zend_uchar is_ref__gc; //表示是否为引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP之道--《编程范式》篇</title>
    <link href="http://yoursite.com/2018/09/16/20180916/"/>
    <id>http://yoursite.com/2018/09/16/20180916/</id>
    <published>2018-09-16T15:50:01.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;p&gt;PHP 5 支持抽象类和抽象方法。&lt;strong&gt;定义为抽象的类不能被实例化&lt;/strong&gt;。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。&lt;/strong&gt;例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>打造 Laravel 优美架构 谈可维护性与弹性设计</title>
    <link href="http://yoursite.com/2018/09/06/20180906/"/>
    <id>http://yoursite.com/2018/09/06/20180906/</id>
    <published>2018-09-06T15:10:32.000Z</published>
    <updated>2018-11-08T14:17:39.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;公司项目可能需要对架构进行重建，老大给了我一个视频让我学习里面的思想，看完后觉得收获很大，主讲人对laravel项目各个层次有很清晰的理解，力求做到职责单一分明，提高可维护性。下面是我看完视频对其内容的大概整理，以及一些自己的见解，有错误的请指出。&lt;br&gt;视频：&lt;a href=&quot;https://www.youtube.com/watch?v=pzY0FBafXd0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.youtube.com/watch?v=pzY0FBafXd0&lt;/a&gt; (有墙各位懂的)&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="Web知识" scheme="http://yoursite.com/tags/Web%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击与防御</title>
    <link href="http://yoursite.com/2018/09/05/20180905/"/>
    <id>http://yoursite.com/2018/09/05/20180905/</id>
    <published>2018-09-05T13:40:16.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;转载地址：&lt;a href=&quot;https://blog.csdn.net/stpeace/article/details/53512283&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/stpeace/article/details/53512283&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;CSRF概念&quot;&gt;&lt;a href=&quot;#CSRF概念&quot; class=&quot;headerlink&quot; title=&quot;CSRF概念&quot;&gt;&lt;/a&gt;CSRF概念&lt;/h4&gt;&lt;p&gt;CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web  A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Web知识" scheme="http://yoursite.com/tags/Web%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 实现单用户登录</title>
    <link href="http://yoursite.com/2018/09/04/20180904/"/>
    <id>http://yoursite.com/2018/09/04/20180904/</id>
    <published>2018-09-04T12:16:40.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;需求：同一时间只能有一个人登录账号，后登录者会把前登录者顶下线&lt;br&gt;参考：&lt;a href=&quot;https://laravel-china.org/articles/2929/laravel-single-user-login&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://laravel-china.org/articles/2929/laravel-single-user-login&lt;/a&gt;&lt;br&gt;    　&lt;a href=&quot;https://segmentfault.com/a/1190000007906164&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000007906164&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;关键思路：登录时制作一个token（根据id-ip-time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth-logout-重定向到登录页面&quot;&gt;&lt;a href=&quot;#关键思路：登录时制作一个token（根据id-ip-time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth-logout-重定向到登录页面&quot; class=&quot;headerlink&quot; title=&quot;关键思路：登录时制作一个token（根据id,ip,time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth::logout(),重定向到登录页面&quot;&gt;&lt;/a&gt;关键思路：登录时制作一个token（根据id,ip,time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth::logout(),重定向到登录页面&lt;/h4&gt;&lt;p&gt;(原本参考laravel-china的文章使用响应后面添加withCookie来存token，后面想到cookie在浏览器关闭后会被删除，于是使用session)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Nginx与PHP的交互</title>
    <link href="http://yoursite.com/2018/09/02/20180902/"/>
    <id>http://yoursite.com/2018/09/02/20180902/</id>
    <published>2018-09-02T09:30:15.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Nginx是俄国人最早开发的Webserver，现已风靡全球，基本上LNMP成了当下的标配，下面主要根据网上收集的资料，对Nginx如何与php完成交互进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Web知识" scheme="http://yoursite.com/tags/Web%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>phpcs插件规范代码</title>
    <link href="http://yoursite.com/2018/08/13/20180813/"/>
    <id>http://yoursite.com/2018/08/13/20180813/</id>
    <published>2018-08-13T02:01:20.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;正式步入编程应该有1年多了，需要学习的还有数不尽的知识点。代码规范，在工作前我写的代码不多，也不规范不整洁，来到公司第一件事就是看手册，规范手册：&lt;a href=&quot;http://docs.r9it.com/manual/php/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://docs.r9it.com/manual/php/&lt;/a&gt; 但平时习惯一时改不过来，在Laravel China社区看见一篇文章介绍phpcs 插件，能够辅助和实时提醒我们的代码规范性&lt;/p&gt;
&lt;p&gt;Github安装&lt;br&gt;地址：&lt;a href=&quot;https://github.com/squizlabs/PHP_CodeSniffer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/squizlabs/PHP_CodeSniffer&lt;/a&gt;&lt;br&gt;似乎Composer安装时最方便的，我是跟着&lt;a href=&quot;https://laravel-china.org/articles/13006/recommend-a-phpcs-plug-in-to-standardize-laravel-code-specification-from-local-code-to-version-control&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://laravel-china.org/articles/13006/recommend-a-phpcs-plug-in-to-standardize-laravel-code-specification-from-local-code-to-version-control&lt;/a&gt;&lt;br&gt; 这篇文章来安装操作的&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP工具" scheme="http://yoursite.com/tags/PHP%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>手残sudo -R 777 /etc(/usr)后怎么办</title>
    <link href="http://yoursite.com/2018/08/12/20180812/"/>
    <id>http://yoursite.com/2018/08/12/20180812/</id>
    <published>2018-08-12T07:55:02.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>PHP设计模式（一）</title>
    <link href="http://yoursite.com/2018/07/28/20180728/"/>
    <id>http://yoursite.com/2018/07/28/20180728/</id>
    <published>2018-07-28T11:12:40.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;设计模式六大原则&lt;/p&gt;
&lt;p&gt;开放封闭原则：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。&lt;br&gt;里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象.&lt;br&gt;依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。&lt;br&gt;单一职责原则：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。&lt;br&gt;接口隔离原则：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。&lt;br&gt;迪米特法则  ：一个对象应该对其他对象保持最少的了解。&lt;/p&gt;
&lt;h3 id=&quot;单例模式-（创建设计模式）&quot;&gt;&lt;a href=&quot;#单例模式-（创建设计模式）&quot; class=&quot;headerlink&quot; title=&quot;单例模式 （创建设计模式）&quot;&gt;&lt;/a&gt;单例模式 （创建设计模式）&lt;/h3&gt;&lt;p&gt;要点：只有一个实例，作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。&lt;br&gt;常见: 数据库连接，日志错误记录（多种用途使用多种模式）&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
</feed>
