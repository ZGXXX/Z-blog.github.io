<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自行脑补</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-12T09:11:54.988Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Grayson Zhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2019/04/12/20190412/"/>
    <id>http://yoursite.com/2019/04/12/20190412/</id>
    <published>2019-04-12T08:55:11.428Z</published>
    <updated>2019-04-12T09:11:54.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一篇文章讲述了我在三月份毫无准备就去面试的后果，一开始心态真的爆炸，但是又不服气，一想到每次回来后家人朋友问我面试结果的期待脸，越觉得必须付出的行动来证明自己了。</p><blockquote><p>面经传送门：<a href="https://zgxxx.github.io/2019/04/10/20190410/" target="_blank" rel="noopener">一个1年工作经验的PHP程序员是如何被面试官虐的？</a></p></blockquote><p>下面是我花费两个星期做的准备，主要分三部分：</p><ul><li>有计划——计划好每天要复习的知识模块（内容较多）</li><li>高效率——从整体到细节，着重把知识点“手写”到自己的电脑记录本</li><li>优简历——展示你的项目亮点，难点</li></ul><blockquote><p>下面的文章和网站链接我都会注明出处，如果有问题请联系我，我会及时修改或撤销</p></blockquote><h2 id="有计划"><a href="#有计划" class="headerlink" title="有计划"></a>有计划</h2><p>反思：为什么好多知识看过后不能记住，面试一紧张更加想不起？一方面自己没有深入学习，另一方面复习过程杂乱，和写代码一个道理，如果你的业务逻辑和其他乱七八糟的都放在控制器上，代码一多你要调用某个方法可能就会让你抓狂，所以一般采取controller和server分层，同理，我们最好提前做好计划，分种类，分层次来学习。</p><blockquote><p>复习前如果很迷茫，可以网上Google一下面试知识点，看到的无非都是操作系统，计算机网络，数据结构，mysql，设计模式，Linux，Redis，再者根据你所学语言方面的知识和简历，例如我求职PHP，简历上有写Larvel框架，那就再加PHP基础，框架Laravel，服务器nginx。</p></blockquote><a id="more"></a><h3 id="第一天：操作系统"><a href="#第一天：操作系统" class="headerlink" title="第一天：操作系统"></a>第一天：操作系统</h3><p>如果你是科班出身，那应该对操作系统不陌生，至少在高校里面是学过这门课程的。但估计很多人像我一样，后悔没去好好学这门课，或者工作上用不上就抛弃它了（PHP更是如此），我要说的是操作系统很重要，就以我面试了几家公司来说，基本如果你答出操作系统相关知识点基本都是加分的。</p><ol><li>进程和线程的概念，以及两者的区别</li><li>什么是上下文切换</li><li>多进程和多线程各自的优势（可以Google一下有关php-fpm和nginx进程）</li><li>进程通信方式</li><li>进程基本状态</li><li>抢占式调度和非抢占式调度</li><li>进程线程同步，死锁</li><li>理解协程</li></ol><p>附加帮助我整理这些知识的网站和博客文章：</p><p><a href="https://wdxtub.com/interview/14520847747820.html" target="_blank" rel="noopener">小土刀的面试刷题笔记——操作系统</a></p><p><a href="https://hit-alibaba.github.io/interview/basic/arch/Concurrency.html" target="_blank" rel="noopener">并发技术·笔试面试知识整理</a></p><blockquote><p>这里推荐有精力的朋友可以看下《Linux高性能服务器编程》，粗略看下8，9，10，13，14章，以及《深入理解计算机系统》的第1章和第12章，我就是结合这两本书，记住并理解简单的知识点，后续我还要花时间去深入阅读。</p></blockquote><h3 id="第二天：计算机网络"><a href="#第二天：计算机网络" class="headerlink" title="第二天：计算机网络"></a>第二天：计算机网络</h3><p>计算机网络可以说是大多数程序员需要学习的大课程，特别是PHPer这些web打交道的程序员。当然，计算机网络太底层的东西很枯燥很难懂，我只针对一些比较常见，比较基础的知识面来学习。</p><ol><li>计算机网络体系包括TCP/IP体系结构，五层协议体系结构</li><li>TCP，UDP</li><li>三次握手，四次握手（过程要熟悉，能清晰描述）</li><li>TCP协议如何保证可靠传输（包括重传，流量控制，拥塞控制，定时器等知识点要了解）</li></ol><p>附加帮助我整理这些知识的网站和博客文章：</p><p><a href="https://wdxtub.com/interview/14520847385821.html" target="_blank" rel="noopener">小土刀的面试刷题笔记——网络</a></p><p><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">TCP协议·笔试面试知识整理</a></p><p>复习完这些基础的知识后，试着要去了解稍微底层一点的东西，因为很多面试官喜欢由浅入深地问，如果能答出一两点基本都是加分的</p><p>推荐一篇很好的文章，仔细读完会有很大的收获：</p><p><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿（上）</a></p><h3 id="第三天：数据结构"><a href="#第三天：数据结构" class="headerlink" title="第三天：数据结构"></a>第三天：数据结构</h3><p>很多人在大学里面都学过这门课程，也是很多程序员的启蒙课程，自然很重要，（大学唯一一次挂科就是它了。。。）</p><p>从事PHP工作的朋友应该都用不上它，所以这也是一个很容易被忽视的基础知识点，自然有很多大公司面试的时候很注重这方面的基础，特别是应届毕业生。我复习这方面的知识是重新翻开我大学的课本，把其中比较重要的东西手写几遍。</p><blockquote><p>我不久前面试过一家要我手写链表，结果早就忘了，没写出来</p></blockquote><ol><li>队列，循环队列，栈，单链表等，要理解，最好多手写几遍</li><li>树和图，着重复习二叉树方面的知识，例如前中后遍历；B树，B+树，红黑树最好要了解一下</li><li>排序算法，冒泡排序必须很熟悉，其他几种常见的算法：简单选择排序，直接插入排序，快速排序也要知道</li></ol><blockquote><p>冒泡排序可以了解下如何优化改进，有些面试官会问，如果答不出他会提示你怎么做，考察你的思考能力</p></blockquote><p>关于数据结构的参考资料基本Google一下就有很多（顺便说下，21世纪程序员还是少用某度），大学的课程书是最好的，一般大学的数据结构都是面向学生的，还是很基础，很好理解的。</p><h3 id="第四天：数据库mysql"><a href="#第四天：数据库mysql" class="headerlink" title="第四天：数据库mysql"></a>第四天：数据库mysql</h3><p>说实话，我觉得绝大多数程序员都是在CURD，学那么多东西很大方面也是为了辅助最后的curd。所以数据库知识的重要性毋庸置疑，后面我打算买本《高性能MySQL》来提升自己这方面的能力。</p><ol><li>基础的增删改查操作</li><li>存储引擎MyISAM和InnoDB</li><li>理解索引数据结构，即B+树方面的知识    参考:<a href="https://www.kancloud.cn/kancloud/theory-of-mysql-index/41850" target="_blank" rel="noopener">InnoDB索引实现·MySQL索引背后的数据结构及算法原理·看云</a></li><li>mysql语句优化，着重索引优化，explain查看索引情况    参考:<a href="https://segmentfault.com/a/1190000009717352" target="_blank" rel="noopener">Mysql索引优化</a></li><li>事务四大特性</li><li>隔离级别</li><li>脏读，不可重复读，幻读</li><li>了解共享锁，排他锁，死锁</li><li>了解主从复制原理，分库分表</li></ol><h3 id="第五天：nginx和PHP-fpm"><a href="#第五天：nginx和PHP-fpm" class="headerlink" title="第五天：nginx和PHP-fpm"></a>第五天：nginx和PHP-fpm</h3><p>nginx和php-fpm应该算是PHP程序员接触比较多，但是可能没有去深入了解过，有些面试官喜欢结合nginx，php-fpm和操作系统进程方面的知识来考察。</p><ol><li>日常用到的nginx配置语法，常用的变量</li><li>nginx常见的参数优化    参考:<a href="https://segmentfault.com/a/1190000011405320" target="_blank" rel="noopener">Nginx高并发下的优化</a></li><li>nginx负载均衡，访问控制，防盗链，设置静态文件过期时间等</li><li>php-fpm工作流程</li><li>php-fpm进程管理（静态和动态）</li></ol><p>可以Google了解下php-fpm和nginx各自的进程管理模式，参考文章：<a href="https://segmentfault.com/q/1010000003901360" target="_blank" rel="noopener">Nginx内部有使用多线程吗？</a></p><p>面试过程可能会问到网站负载低，访问慢怎么排查，参考：<a href="https://blog.51cto.com/wwdhks/798321" target="_blank" rel="noopener">论坛偶尔出现负载低但是访问很慢排查思路</a></p><h3 id="第六天：redis"><a href="#第六天：redis" class="headerlink" title="第六天：redis"></a>第六天：redis</h3><p>工作项目不大，用到redis的地方并不多，所以一直也没去学习redis，但是从面试情况看来，被问到redis的概率还是很大的，毕竟这款基于内存的数据库功能强大，市场占用率很高。</p><ol><li>与memcached的区别</li><li>5种基本的数据结构以及各自的使用场景，最好能结合自己项目来描述</li><li>持久化，RDB和AOF   参考： <a href="https://juejin.im/post/5c98d656e51d4542e812f2ee" target="_blank" rel="noopener">面试中经常被问到的 Redis 持久化与恢复</a></li><li>如何与mysql保持数据一致    参考：<a href="https://juejin.im/post/5c96fb795188252d5f0fdff2?utm_source=coffeephp.com" target="_blank" rel="noopener">Redis和mysql数据怎么保持数据一致的？</a></li></ol><h3 id="第七天：Laravel"><a href="#第七天：Laravel" class="headerlink" title="第七天：Laravel"></a>第七天：Laravel</h3><p>由于我自己是一直用Laravel框架开发的，简历里面的项目也多处标明Larvel，所以这里就介绍Larvel相关的知识，你对哪个框架熟悉就去做相应的复习，基本Google和手册都有。</p><ol><li>Laravel生命周期</li><li>什么是服务容器，服务提供器，Facade门面</li><li>依赖注入</li><li>中间件，异常处理，ORM等手册上的知识</li></ol><h3 id="第八天：设计模式"><a href="#第八天：设计模式" class="headerlink" title="第八天：设计模式"></a>第八天：设计模式</h3><p>看一个人的代码水平，可以从是否灵活使用设计模式看出来的。写代码也是一门艺术，好的代码低耦合，易扩展，设计模式的理解和使用也决定了你的代码水平。这里推荐一本《大话设计模式》，目前我只看了一点点，对于我这样的菜鸟觉得还不错，后面需抽点时间好好看看。</p><ol><li>六大原则，着重理解，最好能清晰口述</li><li>结合你的项目经验描述几个设计模式。常见的有单例，三大工厂，观察者，策略等</li></ol><blockquote><p>有一次面试官问我简单工厂模式是不是符合六大原则之一开闭原则？我答不出来，随便选了个符合。。。实际简单工厂是不符合开闭原则的，这就涉及到你开闭原则的理解。</p></blockquote><h3 id="第九天：PHP内核基础知识"><a href="#第九天：PHP内核基础知识" class="headerlink" title="第九天：PHP内核基础知识"></a>第九天：PHP内核基础知识</h3><p>真正要读懂PHP内核的人应该很少，大多数人都没时间和精力去研究底层，毕竟PHP一直以开发效率高著称，只要底层有人写好给广大程序员用就好了。确实是这样，但是我记得有个面试过我的大佬跟我说，很多东西不要只会用，要多想想为什么可以这样用，PHP语言我觉得也是一样，虽然现在能力有限，但我可以提前把一些比较基础，容易理解的底层知识学习一下，这不也是一种自我提升？面试的时候你也可以拿出来炫一下，说错也没关系，至少你展示出你的好学，你的认知层面。</p><ol><li>PHP的生命周期和zend引擎</li><li>变量存储结构</li><li>写时复制和引用</li></ol><p>参考文章：</p><p><a href="http://php-internals.com/book/?p=chapt02/02-01-php-life-cycle-and-zend-engine" target="_blank" rel="noopener">深入理解PHP内核</a></p><p><a href="https://www.kancloud.cn/lifei6671/php-kernel/674581" target="_blank" rel="noopener">PHP内核剖析</a></p><h3 id="第十天：根据你的简历内容做复习"><a href="#第十天：根据你的简历内容做复习" class="headerlink" title="第十天：根据你的简历内容做复习"></a>第十天：根据你的简历内容做复习</h3><p>面试都是拿着你的简历来问问题的，你的简历内容会直接影响面试内容的走向，所以简历写完还要做响应的复习。</p><p>我的简历有涉及rabbitMQ,elasticsearch等知识，我就对其进行简单的复习。</p><p>另外很重要的一点：提前想好怎么描述你做过的项目，其中遇到什么问题，怎么解决，尽量把你好的一面展示出来，这些都可以提前写下了的，好记性不如烂笔头，下面第二部分会说到。</p><h2 id="高效率"><a href="#高效率" class="headerlink" title="高效率"></a>高效率</h2><p>复习的内容实在是太多了，单单写上一部分内容都快把我的键盘打烂，手写断了。虽然有了十全的计划，但如何高效率去记住上面那么多东西是一个大问题，看看我是怎么做的。</p><ul><li>例如第一天复习操作系统的知识，我是早上Google了一下有关操作系统的面试知识点，然后打开几个标签页，选取内容比较齐全的。所谓“好记性不如烂笔头”，没有烂笔头，只有烂键盘，所以我选择把这些知识点一一整理到自己的电脑上，自己平时有写博客，用markdown比较多（推荐Typora），所以每天就用一个md文件把知识整理下来，基本都是手打的，很少复制黏贴。这样做，一方面让自己印象深刻，另一方面锻炼自己摘取核心内容，描述能力，这也是我能写下这么多内容的原因。</li><li>每天晚上计划好明天的复习内容，可以选择睡前回顾今天学习的知识，也可以在第二天早上回顾一遍</li><li>最好选择一个安静的地方，能让你认真学习的环境，我由于提交了离职申请需要一个月才能走，交接项目也很快，所以每天都在公司有计划的复习（远离手机）</li></ul><p>总之，真想要离职，找一份好工作，必须对自己狠一点，找到心仪的工作再好好去放松几天。其实有不少人一直在埋怨大环境不好，确实是，但有何用，想为自己菜，自己不努力找一个借口？王小波说的好：人的一切痛苦，本质上都是对自己无能的愤怒。当然运气也很重要，保持乐观，别轻易放弃。</p><h2 id="优简历"><a href="#优简历" class="headerlink" title="优简历"></a>优简历</h2><p>简历不用多说，就是很重要，怎么写？其实我也是参考一篇文章的：<a href="https://segmentfault.com/a/1190000018378234" target="_blank" rel="noopener">我本以为你们会写简历</a></p><p>概括一下：</p><ol><li><p>基本的，用PDF格式，个人信息写完整，别写精通</p></li><li><p>技能亮点，围绕 <em>熟悉 , 有所 , 掌握 , 了解 , 有一定心得</em>  等</p><p>不要这样：</p><blockquote><p>熟悉PHP , 熟悉YiiLavarel框架 ( 复制粘贴 , CURD , 就是干! )<br>熟悉Linux使用 , 可以搭建XXXX环境 ( 会敲cd , ls命令 , 会apt install nginx )<br>熟悉git或svn版本管理的使用 ( 会git push , 会git pull )<br>熟悉MySQL以及对数据库的优化 ( 会select update 和 delete , 会添加索引 )<br>熟悉Redis或Memcache的使用 ( 会set key , 会get key )</p></blockquote><p>最好这样：</p><blockquote><p>PHP : 熟悉PHP语法 , 熟悉PHP面向对象 , 可以根据业务逻辑结合合适的设计模式 . 熟悉PHP SPL标准库 , 对PHP的一些高级用法有所心得体验 , 诸如pcntl多进程模块 , socket模块 . 对SWOOLE所有涉猎 , 有一些自己的积累和经验 . 对于底层 , ZendVM如何如何 。<br>Redis : 熟悉Redis常用数据结构的使用 , 可结合业务场景选择合适的数据结构 . 熟悉Redis集群 , 对集群实现方案原理有一定掌握 , 对于市面常用的集中集群方案的优缺点比较了解 . 对于底层 , 对Redis SET等底层数据结构的实现有所掌握。</p></blockquote></li><li><p>一定要写项目亮点和难点</p><blockquote><p>大多数人都是这么写的 : 负责用户登录注册模块 , 后台管理 , 多角色权限控制 , 负责广告业务模块的管理和筛查(太普通，太泛了)</p></blockquote></li></ol><ul><li>亮点 . 你觉得这个项目中哪一部分值得自豪或学到新东西了 . 比如项目中用到ECDH , 使用了MySQL中间件等等。</li><li>难点 . 你觉得这个项目哪一部分当时难了你几天 , 然后你通过自己努力解决了以及解决方案是什么。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面试并不简单，不要太轻敌，做好准备，打好基础是关键。毫无准备就去投简历面试大多是浪费时间，甚至浪费进入好公司的机会。还是那句话程序员应该脚踏实地，不要眼高手低，用实际行动证明自己。</p><p>我是即将入职广州一家游戏公司PHP开发岗位的程序员，2018年毕业，毕业到现在确实收获了不少，也让我看清自己，需要恶补的知识还有很多很多。欢迎大家关注我的个人博客<a href="https://zgxxx.github.io/" target="_blank" rel="noopener">https://zgxxx.github.io/</a>，比较简陋，还是希望能和万千大神交流技术问题，一起成长。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前一篇文章讲述了我在三月份毫无准备就去面试的后果，一开始心态真的爆炸，但是又不服气，一想到每次回来后家人朋友问我面试结果的期待脸，越觉得必须付出的行动来证明自己了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;面经传送门：&lt;a href=&quot;https://zgxxx.github.io/2019/04/10/20190410/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一个1年工作经验的PHP程序员是如何被面试官虐的？&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面是我花费两个星期做的准备，主要分三部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有计划——计划好每天要复习的知识模块（内容较多）&lt;/li&gt;
&lt;li&gt;高效率——从整体到细节，着重把知识点“手写”到自己的电脑记录本&lt;/li&gt;
&lt;li&gt;优简历——展示你的项目亮点，难点&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;下面的文章和网站链接我都会注明出处，如果有问题请联系我，我会及时修改或撤销&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;有计划&quot;&gt;&lt;a href=&quot;#有计划&quot; class=&quot;headerlink&quot; title=&quot;有计划&quot;&gt;&lt;/a&gt;有计划&lt;/h2&gt;&lt;p&gt;反思：为什么好多知识看过后不能记住，面试一紧张更加想不起？一方面自己没有深入学习，另一方面复习过程杂乱，和写代码一个道理，如果你的业务逻辑和其他乱七八糟的都放在控制器上，代码一多你要调用某个方法可能就会让你抓狂，所以一般采取controller和server分层，同理，我们最好提前做好计划，分种类，分层次来学习。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;复习前如果很迷茫，可以网上Google一下面试知识点，看到的无非都是操作系统，计算机网络，数据结构，mysql，设计模式，Linux，Redis，再者根据你所学语言方面的知识和简历，例如我求职PHP，简历上有写Larvel框架，那就再加PHP基础，框架Laravel，服务器nginx。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一个1年工作经验的PHP程序员是如何被面试官虐的？</title>
    <link href="http://yoursite.com/2019/04/10/20190410/"/>
    <id>http://yoursite.com/2019/04/10/20190410/</id>
    <published>2019-04-10T09:49:35.545Z</published>
    <updated>2019-04-10T10:12:48.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先需要说明的一点，本人只是一个毕业一年，只有一年工作经验的普通PHPer，能力有限，这篇文章只是将我这几周来的感受和体验分享出来，希望能给许多像我一样，或者互联网行业的新手带来一些收获，当然哪里说的不对或不足还是希望大神们可以加以点评补充。</p><p>金三银四，每年这个时候都有很多人想借此机会跳槽或者投身某个行业，目的很明确：需求更好的环境，兑现自己的价值。特别是近十年来非常火爆的互联网行业，无论是刚毕业的，敲代码敲了几年的，还是跨行进入IT行业的，都希望自己能“拿高薪，学知识，享福利”，而如今，高校扩招，IT门槛降低也导致市场太多“低技术，高目标”的幼年程序猿（我也是其中之一），再加上今年互联网寒冬，僧多粥少，想要寻求一个面试机会都不容易，更别说拿offer了。我是不甘心浪费时间在目前这家公司，具体原因不说，所以我下定决心找一份新的工作，一方面证明自己，另一方面想让自己走出舒适圈，给自己多一点挑战。</p><h2 id="狼狈的三月"><a href="#狼狈的三月" class="headerlink" title="狼狈的三月"></a>狼狈的三月</h2><p>一开始心高气傲的我，用半天时间把自己的简历整理了一遍，那时候我的简历应该还是不错的（后续文章会详细描述如何优化简历），第二天开始在Boss直聘和拉勾上开始投递简历，一开始投递的是广州地区PHP的1-3年开发岗位，虽然反馈比例不高，但还是很幸运收到几个面试邀请。接着我留了两天时间给自己复习，其实也就是在网上Google一下PHP面试题，打开十几个标签页各种面试题，这就是我所谓的“多刷题”操作，结果可想而知，看的东西很乱导致去面试那天基本忘的七七八八，有很多还只是记住一些答案，压根就没清楚，惨状见下面具体面试。</p><a id="more"></a><h3 id="准备不充分-–-第一轮不过"><a href="#准备不充分-–-第一轮不过" class="headerlink" title="准备不充分 – 第一轮不过"></a>准备不充分 – 第一轮不过</h3><p>第一家，广州琶洲一家环境超级好，福利也不错，主营美颜APP的公司，这也是我最感遗憾的一次面试机会。一开始有笔试，主要内容有点偏向C语言那方面，PHP的几乎没有，仅靠大学的模糊知识写了一些答案，具体的时间有点久忘记了，这里就不详细说笔试内容。主要是第一轮面试：</p><ul><li>第一个问题：Redis的5种数据类型，只答了一个String。</li><li>第二个问题：你知道Redis怎么做到数据落地，同步数据库吗？连数据类型都不知道，我只能说不清楚，没用过。</li><li>第三个问题：如果数据库量很大，你怎么优化？我的回答：做好索引，mysql语句优化。</li><li>第四个问题：在工作中你做了哪些mysql语句优化？我的回答：我用where in（id1,id2…）来做优化。。。</li></ul><blockquote><p>一年的PHP开发中其实我没怎么用过Redis，就简单的用过String（也看出我真的菜）</p><p>其实where in那个是Laravel ORM预加载使用where in来解决N + 1问题（具体可以看Larave手册），where in并不比left join效率高    </p></blockquote><p>最后聊了差不多20分钟，就让hr来问我一些问题，例如我对公司的印象等，应该就是走走流程，接着就让我回去等通知，当然也就没通知了。</p><h3 id="基础不过关-–-第二轮不过"><a href="#基础不过关-–-第二轮不过" class="headerlink" title="基础不过关 – 第二轮不过"></a>基础不过关 – 第二轮不过</h3><p>第二家，深圳大学旁边一家保险业务的公司，给了我最大的打击。没有笔试题，第一轮是一个差不多和我同龄的年轻小伙来面试，问的问题很简单，基本都是网上那些面试题，比如tcp和udp的区别，三次握手，include/require的区别等，我基本都回答出来了。接着是一个头发相对稀疏，经验应该更加老道的人来面试我：</p><ul><li>我的简历有提到一个JWT相关的知识，所以他让我描述具体的东西，和session的区别等。项目时间有点久，我也就简单的把jwt的东西跟他说，但是明显不能满足他，一直问到底层，那时候我就很慌了，更加想不起来了。</li><li>PHP这些框架是怎么实现文件自动加载的？我回答魔术方法__autoload和include，对方反问了一句再具体一点，还有没有别的？我实在想不出</li><li>写一个链表吧？不会。。。</li></ul><blockquote><p>其实有关JWT的问题，面试官应该是没用过，服务器这边其实有一个私钥Secret字符串用来签名，从而达到前后加密解密验证的效果</p><p>第二个问题应该是还有一个spl_autoload_register可以用来注册多个文件</p><p>第三个链表，后悔大学没好好学数据结构，后续得补一补</p></blockquote><p>最后面试官直接给结果：很抱歉，你的不适合我们公司，希望你之后多去补一补基础知识，不要只停留在会用，要知道为什么可以这样用。</p><p>虽然打击很大，但是也是这个面试让我认清自己，知道自己欠缺的知识面太多，基础太差了。</p><blockquote><p>还是很喜欢这种面试直接给面试结果的。</p></blockquote><h3 id="实践不足，知识面太窄-–-直接不过"><a href="#实践不足，知识面太窄-–-直接不过" class="headerlink" title="实践不足，知识面太窄 – 直接不过"></a>实践不足，知识面太窄 – 直接不过</h3><p>第三家，面试官是大牛，之前和韩天峰大神一起做朋友网的，人很好，很亲切。没有笔试，没有自我介绍，主要问我的工作经历，印象比较深的是：有没有抓过包，用什么工具，对TCP的理解，有没有用一些语言来实现TCP的过程。。。无奈自己真的没实践过，知识面太窄了，仅仅知道一点死记硬背的知识，聊了20分钟，就走了，也没结果了。</p><h3 id="白高兴的offer-–-幸运过了"><a href="#白高兴的offer-–-幸运过了" class="headerlink" title="白高兴的offer – 幸运过了"></a>白高兴的offer – 幸运过了</h3><p>第四家，也是在深圳，招聘网上看到的公司不小，有100-500人，但发offer却是另外一家公司，网上查了一下貌似是子公司，有点外包性质。没有笔试，一个年轻的小伙子面试的我，主要问我一些有关Laravel的内容，一般手册上都有，我答的也不怎么完整。最后有个问题：你知道哪些设计模式，六大原则是什么？对设计模式我只停留在单例和工厂模式，六大原则也回答不完整。</p><p>最后很意外让我过了，我想是公司急需人员。给的薪资也挺满意，心想面试了那么多家终于有一家肯收留我了，也答应了对方下一周就过去上班。第二天回公司第一件事就是找我们总监要辞职，要一个星期后走，结果被告知要走一个月的交接流程，其实那时候我东西基本交接的差不多了，项目也不大，但是公司给的理由是，如果你没有工作交接说明你平时没做事，工作不饱和，会影响后续招人。直接把我整懵逼了，一方面我不敢提前裸辞，很多人都是互联网寒冬，所以就等到拿了offer再提离职，这时候老东家行政放话一定要走一个月流程，新的公司又继续一个星期后到岗，怎么都没得商量。。。最后，我还是放弃那个offer，一方面想到这家公司有点外包性质，另一方面以子公司名字来发offer总让我有点担心，毕竟之前实习的时候，有一家以腾讯的名字来招聘，进去后发现是腾讯汽车代理商。。。</p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>以上便是三月份我面试过比较印象深刻的公司，基本都是被虐了，当然无非都是自己没有好好准备，基础不好的问题，导致浪费了很多机会。所以在此还是要告诫大家，如果下定决心要走人，要做好十足的准备，这种准备不应该只是所谓的刷面试题，后续我会另外开一篇文章用来具体讲述我在多次面试失败后，如何花两个星期做到——”有计划， 高效率，优简历“，最后成功拿到自己心仪的offer。</p><blockquote><p>有计划——如果规划好每天的学习目标，主要有操作系统，计算机网络，mysql等近10个方面知识</p><p>高效率——我会介绍我如何高效记住一些核心知识，尽可能覆盖面试知识点</p><p>优简历——面试是第一步，简历是最关键的，我会介绍我是如何优化自己的简历</p></blockquote><p>三月份投的简历应该有上百家，反馈的十几家，给面试的应该就只有七八个吧，除了上面说的几家其他的都是一些外包或创业公司，甚至有人找过我要我跟他们一起创业，和一个前端实习生一起开发小程序（笑哭）。总之目前这种市场状况不好，但是还是有机会拿到面试机会的，如果你刚毕业，最好走校招，如果你和我一样，一两年工作经验，更应该好好准备，而不是埋怨环境不好，只想不做。当然，一些985，211的大神就应该找大厂或者考研，目标更远大一点，我是比较考虑现实的人，目前我的实力和教育背景想要去大厂是很困难的，所以只能在条件不至于太差的中小型公司寻求成长。程序员更应该用实际行动来证明自己，脚踏实地，不要眼高手低，这便是我的个人想法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;首先需要说明的一点，本人只是一个毕业一年，只有一年工作经验的普通PHPer，能力有限，这篇文章只是将我这几周来的感受和体验分享出来，希望能给许多像我一样，或者互联网行业的新手带来一些收获，当然哪里说的不对或不足还是希望大神们可以加以点评补充。&lt;/p&gt;
&lt;p&gt;金三银四，每年这个时候都有很多人想借此机会跳槽或者投身某个行业，目的很明确：需求更好的环境，兑现自己的价值。特别是近十年来非常火爆的互联网行业，无论是刚毕业的，敲代码敲了几年的，还是跨行进入IT行业的，都希望自己能“拿高薪，学知识，享福利”，而如今，高校扩招，IT门槛降低也导致市场太多“低技术，高目标”的幼年程序猿（我也是其中之一），再加上今年互联网寒冬，僧多粥少，想要寻求一个面试机会都不容易，更别说拿offer了。我是不甘心浪费时间在目前这家公司，具体原因不说，所以我下定决心找一份新的工作，一方面证明自己，另一方面想让自己走出舒适圈，给自己多一点挑战。&lt;/p&gt;
&lt;h2 id=&quot;狼狈的三月&quot;&gt;&lt;a href=&quot;#狼狈的三月&quot; class=&quot;headerlink&quot; title=&quot;狼狈的三月&quot;&gt;&lt;/a&gt;狼狈的三月&lt;/h2&gt;&lt;p&gt;一开始心高气傲的我，用半天时间把自己的简历整理了一遍，那时候我的简历应该还是不错的（后续文章会详细描述如何优化简历），第二天开始在Boss直聘和拉勾上开始投递简历，一开始投递的是广州地区PHP的1-3年开发岗位，虽然反馈比例不高，但还是很幸运收到几个面试邀请。接着我留了两天时间给自己复习，其实也就是在网上Google一下PHP面试题，打开十几个标签页各种面试题，这就是我所谓的“多刷题”操作，结果可想而知，看的东西很乱导致去面试那天基本忘的七七八八，有很多还只是记住一些答案，压根就没清楚，惨状见下面具体面试。&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>PHP对象深拷贝与浅拷贝</title>
    <link href="http://yoursite.com/2019/02/27/20190227/"/>
    <id>http://yoursite.com/2019/02/27/20190227/</id>
    <published>2019-02-27T03:38:19.028Z</published>
    <updated>2019-02-27T05:59:30.460Z</updated>
    
    <content type="html"><![CDATA[<p>php对象的赋值是引用赋值，可以参考之前一篇文章<a href="https://zgxxx.github.io/2018/09/16/20180916-2/" target="_blank" rel="noopener">PHP之道–对象和引用</a>;</p><p>深拷贝：赋值完全复制，两个对象完全独立，其中一个对象的属性做出改变时不会影响到另一个。</p><p>浅拷贝：引用赋值，相对于取了一个别名，其中一个对象属性做出修改会影响到另一个。</p><h3 id="对象的调用"><a href="#对象的调用" class="headerlink" title="对象的调用"></a>对象的调用</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">a</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> $abc=<span class="string">"ABC"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$b=<span class="keyword">new</span> a;</span><br><span class="line">$c=$b;</span><br><span class="line"><span class="keyword">echo</span> $b-&gt;abc;<span class="comment">//这里输出ABC</span></span><br><span class="line"><span class="keyword">echo</span> $c-&gt;abc;<span class="comment">//这里输出ABC</span></span><br><span class="line">$b-&gt;abc=<span class="string">"DEF"</span>;</span><br><span class="line"><span class="keyword">echo</span> $c-&gt;abc;<span class="comment">//这里输出DEF</span></span><br></pre></td></tr></table></figure><p>对象赋值，浅拷贝。上列中$b=new a; $c=$b; 其实等效于$b=new a; $c=&amp;$b,也就说取了另一个名字而已，指向的内存空间还是一样的。如果想要完全独立出来一个对象，互不影响，这就涉及到clone深拷贝</p><a id="more"></a><h3 id="Clone函数"><a href="#Clone函数" class="headerlink" title="Clone函数"></a>Clone函数</h3><p>clone函数在克隆对象时候，普通属性是深拷贝，但原对象的对象属性还是引用赋值，浅拷贝，看代码理解：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestOne</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $b = <span class="number">1</span>; <span class="comment">//这里就是普通属性</span></span><br><span class="line">    <span class="keyword">public</span> $obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;obj = <span class="keyword">new</span> Test();  <span class="comment">//这个obj就是对象属性，它是一个Test的实例</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$old = <span class="keyword">new</span> TestOne();</span><br><span class="line">$old2 = $old; <span class="comment">//这是完全浅拷贝，和上面对象调用那个例子一样的</span></span><br><span class="line">$new = <span class="keyword">clone</span> $old; <span class="comment">//这里使用了clone函数，普通属性不会被影响，而对象属性会被影响</span></span><br><span class="line"></span><br><span class="line">$new-&gt;b = <span class="number">2</span>; <span class="comment">//改变一下普通属性</span></span><br><span class="line"><span class="keyword">echo</span> $old-&gt;b; <span class="comment">//输出原来的1；说明普通属性是深拷贝</span></span><br><span class="line"></span><br><span class="line">$new-&gt;obj-&gt;a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">echo</span> $old-&gt;obj-&gt;a; <span class="comment">//输出3，说明对象属性是浅拷贝，还是会随着新对象而改变</span></span><br></pre></td></tr></table></figure><h3 id="魔术方法-clone实现真正深拷贝"><a href="#魔术方法-clone实现真正深拷贝" class="headerlink" title="魔术方法__clone实现真正深拷贝"></a>魔术方法__clone实现真正深拷贝</h3><p>为了实现全部属性的深拷贝，可以使用魔术方法__clone</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $a=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestOne</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> $obj;</span><br><span class="line">    <span class="comment">//包含了一个对象属性，clone时，它会是浅拷贝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;obj = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//方法一：重写clone函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;obj = <span class="keyword">clone</span> <span class="keyword">$this</span>-&gt;obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$old = <span class="keyword">new</span> TestOne();</span><br><span class="line">$new = <span class="keyword">clone</span> $old;</span><br><span class="line"> </span><br><span class="line">$new-&gt;b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> $old-&gt;b;<span class="comment">//输出原来的1</span></span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="comment">//可以看到，普通属性实现了深拷贝，改变普通属性b，不会对源对象有影响</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//由于改写了clone函数，现在对象属性也实现了真正的深拷贝，对新对象的改变，不会影响源对象</span></span><br><span class="line">$new-&gt;obj-&gt;a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">echo</span> $old-&gt;obj-&gt;a;<span class="comment">//输出1，不随新对象改变，还是保持了原来的属性</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="序列化反序列化"><a href="#序列化反序列化" class="headerlink" title="序列化反序列化"></a>序列化反序列化</h3><p>如果每次都要去类里面修改__clone会很不方便，而且还必须把所有对象属性都放在__clone里面保证全部深拷贝。可以使用serialize序列化，unserialize反序列化实现对象深拷贝</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $a=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestOne</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $b=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> $obj;</span><br><span class="line">    <span class="comment">//包含了一个对象属性，clone时，它会是浅拷贝</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;obj = <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$m = <span class="keyword">new</span> TestOne();</span><br><span class="line"><span class="comment">//方法二，序列化反序列化实现对象深拷贝</span></span><br><span class="line">$n = serialize($m);</span><br><span class="line">$n = unserialize($n);</span><br><span class="line"> </span><br><span class="line">$n-&gt;b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">echo</span> $m-&gt;b;<span class="comment">//输出原来的1</span></span><br><span class="line"><span class="keyword">echo</span> PHP_EOL;</span><br><span class="line"><span class="comment">//可以看到，普通属性实现了深拷贝，改变普通属性b，不会对源对象有影响</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">$n-&gt;obj-&gt;a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">echo</span> $m-&gt;obj-&gt;a;<span class="comment">//输出1，不随新对象改变，还是保持了原来的属性,可以看到，序列化和反序列化可以实现对象的深拷贝</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>json_encode之后再json_decode,实现赋值也能达到同样效果</p><p>原文参考：<a href="https://www.cnblogs.com/taijun/p/4208008.html" target="_blank" rel="noopener">[PHP中对象的深拷贝与浅拷贝]</a>;</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;php对象的赋值是引用赋值，可以参考之前一篇文章&lt;a href=&quot;https://zgxxx.github.io/2018/09/16/20180916-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PHP之道–对象和引用&lt;/a&gt;;&lt;/p&gt;
&lt;p&gt;深拷贝：赋值完全复制，两个对象完全独立，其中一个对象的属性做出改变时不会影响到另一个。&lt;/p&gt;
&lt;p&gt;浅拷贝：引用赋值，相对于取了一个别名，其中一个对象属性做出修改会影响到另一个。&lt;/p&gt;
&lt;h3 id=&quot;对象的调用&quot;&gt;&lt;a href=&quot;#对象的调用&quot; class=&quot;headerlink&quot; title=&quot;对象的调用&quot;&gt;&lt;/a&gt;对象的调用&lt;/h3&gt;&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;a&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; $abc=&lt;span class=&quot;string&quot;&gt;&quot;ABC&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$b=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; a;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$c=$b;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; $b-&amp;gt;abc;&lt;span class=&quot;comment&quot;&gt;//这里输出ABC&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; $c-&amp;gt;abc;&lt;span class=&quot;comment&quot;&gt;//这里输出ABC&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$b-&amp;gt;abc=&lt;span class=&quot;string&quot;&gt;&quot;DEF&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;echo&lt;/span&gt; $c-&amp;gt;abc;&lt;span class=&quot;comment&quot;&gt;//这里输出DEF&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对象赋值，浅拷贝。上列中$b=new a; $c=$b; 其实等效于$b=new a; $c=&amp;amp;$b,也就说取了另一个名字而已，指向的内存空间还是一样的。如果想要完全独立出来一个对象，互不影响，这就涉及到clone深拷贝&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Laravel关联模型字段取别名查询不出数据的处理方法</title>
    <link href="http://yoursite.com/2019/01/19/20190119/"/>
    <id>http://yoursite.com/2019/01/19/20190119/</id>
    <published>2019-01-19T05:17:35.000Z</published>
    <updated>2019-02-27T05:42:26.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p><img src="https://iocaffcdn.phphub.org/uploads/images/201901/17/28952/hB4XgG3z1D.png!large" alt="file"><br>查询这样的有父子层次关系的菜单数据，例如id=2的数据有子数据，id=3,4,5,6,16，因为后面这些数据的parent_id都是2</p><h2 id="比较笨的办法"><a href="#比较笨的办法" class="headerlink" title="比较笨的办法"></a>比较笨的办法</h2><p>先查询每一条数据，然后再遍历查询parent_id = 每一条数据的id，最后数组拼接。这种方法不仅笨，查询次数还多，完全没必要。</p><h2 id="模型自关联"><a href="#模型自关联" class="headerlink" title="模型自关联"></a>模型自关联</h2><p>laravel自带的ORM是个神器，针对这种有关系的数据，完全可以使用关系模型，既简单又实用，由于这里只有一个数据表，关系也存在于同一张表，所以可以直接使用自关联，将两个关系定义在同一个Model里面：<br><a id="more"></a><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;hasOne(<span class="keyword">$this</span>, <span class="string">'id'</span>, <span class="string">'parent_id'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;hasMany(<span class="keyword">$this</span>, <span class="string">'parent_id'</span>, <span class="string">'id'</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>关系定义里面的参数也可以这样写：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;hasOne(get_class(<span class="keyword">$this</span>), <span class="keyword">$this</span>-&gt;getKeyName(), <span class="string">'parent_id'</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">children</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;hasMany(get_class(<span class="keyword">$this</span>), <span class="string">'parent_id'</span>, <span class="keyword">$this</span>-&gt;getKeyName());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h2 id="查询包含子菜单的数据"><a href="#查询包含子菜单的数据" class="headerlink" title="查询包含子菜单的数据"></a>查询包含子菜单的数据</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Admin_menu::with([<span class="string">'children'</span> =&gt; <span class="function"><span class="keyword">function</span><span class="params">($query)</span></span>&#123;</span><br><span class="line">    $query-&gt;select(<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'parent_id'</span>);</span><br><span class="line">&#125;])</span><br><span class="line">    -&gt;select(<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'parent_id'</span>)</span><br><span class="line">    -&gt;get();</span><br></pre></td></tr></table></figure><p><img src="https://iocaffcdn.phphub.org/uploads/images/201901/17/28952/nlv5419qfu.png!large" alt="file"></p><p>同理查询包含父菜单的数据，将with参数’children’换成’parent’即可。</p><h2 id="关联键取别名查询不出数据"><a href="#关联键取别名查询不出数据" class="headerlink" title="关联键取别名查询不出数据"></a>关联键取别名查询不出数据</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> Admin_menu::with([<span class="string">'children'</span> =&gt; <span class="function"><span class="keyword">function</span><span class="params">($query)</span></span>&#123;</span><br><span class="line">        $query-&gt;select(<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'parent_id'</span>);</span><br><span class="line">    &#125;])</span><br><span class="line">    -&gt;select(<span class="string">'id as MainId'</span>, <span class="string">'title'</span>, <span class="string">'parent_id'</span>)</span><br><span class="line">    -&gt;get();</span><br></pre></td></tr></table></figure><p><img src="https://iocaffcdn.phphub.org/uploads/images/201901/17/28952/FrYIRXQH0q.png!large" alt="file"></p><h2 id="分析sql语句"><a href="#分析sql语句" class="headerlink" title="分析sql语句"></a>分析sql语句</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\DB::connection()-&gt;enableQueryLog(); <span class="comment">// 开启查询日志</span></span><br><span class="line">$menus =  Admin_menu::with([<span class="string">'children'</span> =&gt; <span class="function"><span class="keyword">function</span><span class="params">($query)</span></span>&#123;</span><br><span class="line">$query-&gt;select(<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'parent_id'</span>);</span><br><span class="line">&#125;])</span><br><span class="line">-&gt;select(<span class="string">'id as MainId'</span>, <span class="string">'title'</span>, <span class="string">'parent_id'</span>)</span><br><span class="line">-&gt;get();</span><br><span class="line"><span class="keyword">foreach</span> (\DB::getQueryLog() <span class="keyword">as</span> $sql) &#123;</span><br><span class="line">    dump($sql[<span class="string">'query'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://iocaffcdn.phphub.org/uploads/images/201901/17/28952/Iw7PbP6cFo.png!large" alt="file"><br>打印sql语句，不取别名的情况下，第二条查询，bindings应该是有值的数组，也就是 where in ()是有值可以查询的；给id取了别名后会发现，binding变成null，where in（null）也就查不到数据。</p><blockquote><p>这里我的猜想是，where in （array）这里的array是依赖主键的名称的，在关联查询的时候，已经定义了id = [3,4,5,6…]，但是我们最后给id取了别名，变成MaindId，所以找不到名为id的数组。<br>如果真是这样，我们试着再给它加上id，让它能够找到名为id的数组</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\DB::connection()-&gt;enableQueryLog(); <span class="comment">// 开启查询日志</span></span><br><span class="line">$menus =  Admin_menu::with([<span class="string">'children'</span> =&gt; <span class="function"><span class="keyword">function</span><span class="params">($query)</span></span>&#123;</span><br><span class="line">$query-&gt;select(<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'parent_id'</span>);</span><br><span class="line">&#125;])</span><br><span class="line">-&gt;select(<span class="string">'id'</span>, <span class="string">'id as MainId'</span>, <span class="string">'title'</span>, <span class="string">'parent_id'</span>)</span><br><span class="line">-&gt;get();</span><br><span class="line"><span class="keyword">foreach</span> (\DB::getQueryLog() <span class="keyword">as</span> $sql) &#123;</span><br><span class="line">    dump($sql[<span class="string">'query'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://iocaffcdn.phphub.org/uploads/images/201901/17/28952/sr0XrL1JqJ.png!large" alt="file"><br>这里可以看到bingdings已经不再是null了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然以上取别名问题所在只是我的猜想，但大致可以得出结论：<strong>依赖关联主键localKey的查询，不能缺少相应的字段，也就是说select应该包含对应localKey，如果要取别名应该额外添加</strong>，形如：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select(<span class="string">'id'</span>, <span class="string">'id as MainId'</span>, <span class="string">'title'</span>, <span class="string">'parent_id'</span>, <span class="string">'parent_id as extraId'</span>)</span><br></pre></td></tr></table></figure></p><h2 id="附加另外一种处理数据格式方法"><a href="#附加另外一种处理数据格式方法" class="headerlink" title="附加另外一种处理数据格式方法"></a>附加另外一种处理数据格式方法</h2><p>另外写一个私有的格式处理方法transformer，取别名就交给这个方法来转换<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    $menus = Admin_menu::with([<span class="string">'parent'</span> =&gt; <span class="function"><span class="keyword">function</span><span class="params">($query)</span></span>&#123;</span><br><span class="line">            $query-&gt;select(<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'parent_id'</span>);</span><br><span class="line">        &#125;])</span><br><span class="line">        -&gt;select(<span class="string">'id'</span>, <span class="string">'title'</span>, <span class="string">'parent_id'</span>)</span><br><span class="line">        -&gt;get();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;transformer($menus);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">transformer</span><span class="params">($items)</span> </span>&#123;</span><br><span class="line">    $data = [];</span><br><span class="line">    <span class="keyword">foreach</span> ($items ?? [] <span class="keyword">as</span> $item) &#123;</span><br><span class="line">        $data[] = [</span><br><span class="line">            <span class="string">'mainId'</span> =&gt; $item-&gt;id,</span><br><span class="line">            <span class="string">'title'</span> =&gt; $item-&gt;title,</span><br><span class="line">            <span class="string">'parent_id'</span> =&gt; $item-&gt;parent_id,</span><br><span class="line">            <span class="string">'children'</span> =&gt; $item-&gt;children,</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> $data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://iocaffcdn.phphub.org/uploads/images/201901/17/28952/hB4XgG3z1D.png!large&quot; alt=&quot;file&quot;&gt;&lt;br&gt;查询这样的有父子层次关系的菜单数据，例如id=2的数据有子数据，id=3,4,5,6,16，因为后面这些数据的parent_id都是2&lt;/p&gt;
&lt;h2 id=&quot;比较笨的办法&quot;&gt;&lt;a href=&quot;#比较笨的办法&quot; class=&quot;headerlink&quot; title=&quot;比较笨的办法&quot;&gt;&lt;/a&gt;比较笨的办法&lt;/h2&gt;&lt;p&gt;先查询每一条数据，然后再遍历查询parent_id = 每一条数据的id，最后数组拼接。这种方法不仅笨，查询次数还多，完全没必要。&lt;/p&gt;
&lt;h2 id=&quot;模型自关联&quot;&gt;&lt;a href=&quot;#模型自关联&quot; class=&quot;headerlink&quot; title=&quot;模型自关联&quot;&gt;&lt;/a&gt;模型自关联&lt;/h2&gt;&lt;p&gt;laravel自带的ORM是个神器，针对这种有关系的数据，完全可以使用关系模型，既简单又实用，由于这里只有一个数据表，关系也存在于同一张表，所以可以直接使用自关联，将两个关系定义在同一个Model里面：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>小程序开发初体验</title>
    <link href="http://yoursite.com/2019/01/18/20181222/"/>
    <id>http://yoursite.com/2019/01/18/20181222/</id>
    <published>2019-01-18T13:04:41.000Z</published>
    <updated>2019-01-18T13:04:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp; 已经有一个多月没更新博客了,这个月确实很忙。毕业以来第一次完整负责一个项目，第一次做小程序，第一次部署正式环境，第一次周六加班（我们公司确实不怎么加班哈哈），这段时间确实又让我收获颇多，起码不再像几个月前那样，一个刚毕业的人四处充满疑惑，小心翼翼的打代码，生怕给别人带来麻烦。</p><p>&emsp; 可能因为性格慢热，在熟悉了环境，熟悉了同事，也得到老大的认可的情况下，我开始充满信心和热情去完成我的工作，有疑问的环节依然谦虚的请教，有不满意的地方也平和的提出来。当然，我依旧还有很多地方待提高和完善，知识学习是一方面，还有一方面是自己的脾气，就比如这次小程序上线那天，小程序码识别失败，那天早上我也很着急，排查问题都搞定自己焦头烂耳，我的测试同事过来询问我还要多久才能修复，瞬间我便管不住自己的情绪，带着怒气问为什么你们测试没测出来？后面想想确实是自己的锅，小程序码本来就不能在体验版上测，因为还没发布。今后还需好好管理下自己的脾气……<br>下面是开发小程序的过程踩过的一些坑：<br><a id="more"></a></p><h4 id="体验版某个页面只有打开调试才能请求数据"><a href="#体验版某个页面只有打开调试才能请求数据" class="headerlink" title="体验版某个页面只有打开调试才能请求数据"></a>体验版某个页面只有打开调试才能请求数据</h4><p>这种情况跟后台域名配置有关，例如需要用到微信头像请求<a href="https://wx.qlogo.cn" target="_blank" rel="noopener">https://wx.qlogo.cn</a>, 会显示这个域名不合法，需在后台downloadFile，uploadFile合法域名处加上，然后重启项目</p><h4 id="真机上传图片失败"><a href="#真机上传图片失败" class="headerlink" title="真机上传图片失败"></a>真机上传图片失败</h4><p>拍照上传图片发现有些手机上传图片失败没反应，是后台上传图片失败，文件过大，修改小程序前端拍照图片质量，改为normal就可以，heigh可能过大导致后台php请求文件过大失败(报错413 Request Entity Too Large)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">takePhoto(&#123;</span><br><span class="line">    quality: &quot;normal&quot;,</span><br></pre></td></tr></table></figure><p>如果要从服务端解决：</p><p><img src="https://upload.cc/i1/2018/12/21/MRgsN2.png" alt="服务端解决413报错"></p><h4 id="真机上传图片过慢"><a href="#真机上传图片过慢" class="headerlink" title="真机上传图片过慢"></a>真机上传图片过慢</h4><p>在上传某个图片的操作中，一开始请求时间很长，差不多五六秒，查看原因是前端需要请求一个微信头像<a href="https://wx.qlogo.cn，" target="_blank" rel="noopener">https://wx.qlogo.cn，</a> 这个请求持续四五秒左右，后面google了一下解决方法：<a href="http://www.cnblogs.com/mysic/p/5421754.html" target="_blank" rel="noopener">http://www.cnblogs.com/mysic/p/5421754.html</a></p><p>即后台添加ini_set(‘default_socket_timeout’, 1);限制请求超过1秒就停止，这样请求完微信头像信息立即关闭连接，响应主体connection:keep-alive会变成close</p><h4 id="真机请求某个页面卡顿后才跳转"><a href="#真机请求某个页面卡顿后才跳转" class="headerlink" title="真机请求某个页面卡顿后才跳转"></a>真机请求某个页面卡顿后才跳转</h4><p>真机线上环境在某个页面更新了数据，没有立即显示更新成功，而是卡一小会，再退出页面，这种情况是前端页面报错，但是并没有停止页面继续执行跳转，所以在报错的时候产生卡顿。注意：有时候本地开发pc端一切正常，页面不报错，但是到了移动端可能就因为机型的差别，导致前端某个地方找不到某个属性或者其他报错。</p><h4 id="拍照质量问题"><a href="#拍照质量问题" class="headerlink" title="拍照质量问题"></a>拍照质量问题</h4><p>takephoto拍照质以及涉及到图片上传的，貌似只要是ios图片就会很大，几乎是安卓的10倍，很多地方都要进行压缩，canvasToTempFilePath，takephoto，compressImage等小程序自带功能都有quality属性，ios尽量将其压缩，安卓相对可以大一点，app.systemInfo.platform可以用来区分系统</p><blockquote><p>ios拍照或者生成图片都很大，一般都有七八百k</p></blockquote><h4 id="小程序码"><a href="#小程序码" class="headerlink" title="小程序码"></a>小程序码</h4><p>小程序码是个大坑，特别是带参数的，必须在正式环境测试，因为每次扫描的都是跳到正式发布的页面去，本地根本测试不了</p><p>使用集成包开发有时候也有坑。比如我使用easywechat，这确实是一个很叼的包，很方便，也是腾讯一个大神开发的，在我使用小程序码的时候，一开始我是用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;app_code-&gt;get(string $path, array $optional = []);</span><br></pre></td></tr></table></figure><p>  开发的时候一切没问题，路径也正常跳转，但是后来发现这个方法对应小程序原生方法getWXACode，是有数量限制的，业务需求必须使用另一个没有数量限制的getWXACodeUnlimit，在easywechat里对应</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$app-&gt;app_code-&gt;getUnlimit(string $scene, array $optional = []);</span><br></pre></td></tr></table></figure><p>  <img src="https://upload.cc/i1/2018/12/21/CWXpk9.png" alt=""></p><p>手册说参数optional和get一致，多一个path参数，那我就</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$response = $app-&gt;app_code-&gt;getUnlimit(<span class="string">'scene-value'</span>, [</span><br><span class="line">  <span class="string">'path'</span> =&gt; $myPath</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>就这个死活跳不到我要的地方，都是直接跳首页，也就是说这个路径找不到，或者写错，但是我的路径都检查很多便了，前面也没有加/，就是不行，最后只好放弃，乖乖手动去调用官网的，最后成功。</p><h4 id="mysql排序"><a href="#mysql排序" class="headerlink" title="mysql排序"></a>mysql排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from `card.pvc123.com`.card where `user_id` in (&apos;025c0f52d2027beed4&apos;, &apos;025c1083c7035501ec&apos;, &apos;025c10c14702696714&apos;) </span><br><span class="line">  and `type` = 0 **order by  user_id=&apos;025c1083c7035501ec&apos; desc, user_id=&apos;025c10c14702696714&apos; desc,  `pinyin` asc**</span><br></pre></td></tr></table></figure><h4 id="mysql时间字段判断是否为空"><a href="#mysql时间字段判断是否为空" class="headerlink" title="mysql时间字段判断是否为空"></a>mysql时间字段判断是否为空</h4><p>当mysql某个字段是时间，date,timestamp等，如果默认值是’0000-00-00 00:00:00’ 或CURRENT_TIMESTAMP，使用is not null，is null查询数据不正确，虽然你的数据库看到的时间是空的，但是实际它其实有数据，相当于空字符串，只能用is true来判断。“is true”不等于“ = true”,在laravel用where（’some’, ‘true’）拿到的sql语句是=true，不是is true</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from `card.pvc123.com`.user_relation where `user_id` = &apos;025c1083c7035501ec&apos; and `type` = 2 and `apply_time` is true （laravel whereRaw(&apos;apply_time is true&apos;)）</span><br><span class="line">select * from `card.pvc123.com`.user_relation where `user_id` = &apos;025c1083c7035501ec&apos; and `type` = 2 and `apply_time` = true （laravel where（&apos;apply_time&apos;, &apos;true&apos;）得到的）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp; 已经有一个多月没更新博客了,这个月确实很忙。毕业以来第一次完整负责一个项目，第一次做小程序，第一次部署正式环境，第一次周六加班（我们公司确实不怎么加班哈哈），这段时间确实又让我收获颇多，起码不再像几个月前那样，一个刚毕业的人四处充满疑惑，小心翼翼的打代码，生怕给别人带来麻烦。&lt;/p&gt;
&lt;p&gt;&amp;emsp; 可能因为性格慢热，在熟悉了环境，熟悉了同事，也得到老大的认可的情况下，我开始充满信心和热情去完成我的工作，有疑问的环节依然谦虚的请教，有不满意的地方也平和的提出来。当然，我依旧还有很多地方待提高和完善，知识学习是一方面，还有一方面是自己的脾气，就比如这次小程序上线那天，小程序码识别失败，那天早上我也很着急，排查问题都搞定自己焦头烂耳，我的测试同事过来询问我还要多久才能修复，瞬间我便管不住自己的情绪，带着怒气问为什么你们测试没测出来？后面想想确实是自己的锅，小程序码本来就不能在体验版上测，因为还没发布。今后还需好好管理下自己的脾气……&lt;br&gt;下面是开发小程序的过程踩过的一些坑：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu多版本php切换</title>
    <link href="http://yoursite.com/2019/01/18/20190116/"/>
    <id>http://yoursite.com/2019/01/18/20190116/</id>
    <published>2019-01-18T13:04:31.000Z</published>
    <updated>2019-01-18T13:04:31.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近想要学习一下swoole，虽然机子上装的是php7.0，但是考虑到一些有关swoole的轮子要依赖更高版本（例如swooletw)，所以就在机子上升级了php7.2，下面是在网上搜索或者自己折腾出来的一些笔记。</p><h3 id="版本升级操作-直接从7-0升级到7-2-："><a href="#版本升级操作-直接从7-0升级到7-2-：" class="headerlink" title="版本升级操作(直接从7.0升级到7.2)："></a>版本升级操作(直接从7.0升级到7.2)：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade php</span><br><span class="line"># 拓展升级</span><br><span class="line">sudo apt-get install php7.2-mbstring</span><br><span class="line">sudo apt-get install php7.2-gd</span><br><span class="line">sudo apt-get install php7.2-dom</span><br><span class="line">sudo apt-get install php7.2-mysql</span><br><span class="line">sudo apt-get install php7.2-curl</span><br><span class="line">......</span><br></pre></td></tr></table></figure><a id="more"></a><p>有需要可以安装swoole: <a href="https://wiki.swoole.com/wiki/page/6.html" target="_blank" rel="noopener">https://wiki.swoole.com/wiki/page/6.html</a></p><blockquote><p>这里建议直接用pecl install swoole安装，一步到位，如果手动编译，貌似会出现各种因为版本对应不上的问题。</p></blockquote><h3 id="切换版本："><a href="#切换版本：" class="headerlink" title="切换版本："></a>切换版本：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 禁用7.0版本</span><br><span class="line">sudo a2dismod php7.0</span><br><span class="line"></span><br><span class="line"># 启用7.2版本</span><br><span class="line">sudo a2enmod php7.2</span><br><span class="line"></span><br><span class="line"># 重启nginx(或apache)</span><br><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure><blockquote><p>如果出现ERROR: Module php7.0 does not exist! ，执行sudo apt-get install libapache2-mod-php7.0再执行上面操作</p></blockquote><p>这时候在浏览器查看phpinfo()应该就可以看到7.2版本了，但是命令行cli那里还是7.0，需要执行下面操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 切换cli</span><br><span class="line">sudo update-alternatives --set php /usr/bin/php7.2</span><br></pre></td></tr></table></figure></p><p>这样在命令行执行php -v也能看到7.2版本了</p><blockquote><p>如果有两个版本，其实可以直接用sudo service php7.0-fpm stop/restart来进行切换，当然这只能切换php-fpm，也就是web端，命令行cli端还是不能切换的</p></blockquote><h3 id="Parse-error-syntax-error-unexpected-‘-’-expecting-variable-T-VARIABLE-："><a href="#Parse-error-syntax-error-unexpected-‘-’-expecting-variable-T-VARIABLE-：" class="headerlink" title="Parse error: syntax error, unexpected ‘?’, expecting variable (T_VARIABLE)："></a>Parse error: syntax error, unexpected ‘?’, expecting variable (T_VARIABLE)：</h3><p>升级版本后，我还折腾了php7.1，然后第二天回来启动电脑就发现所以laravel项目都报这样的错，网上搜索后知道是版本问题，但是看了下php -v没问题就是7.2，这时候打算重启php报错，以下的报错就是问题所在了:<br>ERROR: unable to bind listening socket for address ‘127.0.0.1:9001’: Address already in use (98)<br>大致就是端口被占用，然后php fastCGI程序启动失败</p><p>解决方法：<br><strong>ps aux|grep php</strong>查看所有php-fpm进程，发现有个php7.1-fpm进程，拿到进程id，再kill掉就能够重启了。</p><blockquote><p>网上查询的解决方法是killall php-pfm这个命令，执行后只有显示 php-pfm：没有发现操作，这种方法没用，最后使用上面这种查询进程，然后根据进程id杀死进程的方法</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近想要学习一下swoole，虽然机子上装的是php7.0，但是考虑到一些有关swoole的轮子要依赖更高版本（例如swooletw)，所以就在机子上升级了php7.2，下面是在网上搜索或者自己折腾出来的一些笔记。&lt;/p&gt;
&lt;h3 id=&quot;版本升级操作-直接从7-0升级到7-2-：&quot;&gt;&lt;a href=&quot;#版本升级操作-直接从7-0升级到7-2-：&quot; class=&quot;headerlink&quot; title=&quot;版本升级操作(直接从7.0升级到7.2)：&quot;&gt;&lt;/a&gt;版本升级操作(直接从7.0升级到7.2)：&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo add-apt-repository ppa:ondrej/php&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get upgrade php&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 拓展升级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install php7.2-mbstring&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install php7.2-gd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install php7.2-dom&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install php7.2-mysql&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-get install php7.2-curl&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;......&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>使用postman调试jwt开发的接口</title>
    <link href="http://yoursite.com/2018/12/22/20181108/"/>
    <id>http://yoursite.com/2018/12/22/20181108/</id>
    <published>2018-12-22T10:42:39.000Z</published>
    <updated>2018-12-22T10:42:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇博客文章<a href="https://zgxxx.github.io/2018/11/08/20181107/" target="_blank" rel="noopener">https://zgxxx.github.io/2018/11/08/20181107/</a> 介绍了laravel使用dingo+jwt开发API的几个步骤，那么在实际操作中，我们需要测试API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$api = app(&apos;Dingo\Api\Routing\Router&apos;);</span><br><span class="line">$api-&gt;version(&apos;v1&apos;, [&apos;namespace&apos; =&gt; &apos;App\Http\Controllers\V1&apos;], function ($api) &#123;</span><br><span class="line">    $api-&gt;post(&apos;register&apos;, &apos;AuthController@register&apos;);</span><br><span class="line">    $api-&gt;post(&apos;login&apos;, &apos;AuthController@login&apos;);</span><br><span class="line">    $api-&gt;post(&apos;logout&apos;, &apos;AuthController@logout&apos;);</span><br><span class="line">    $api-&gt;post(&apos;refresh&apos;, &apos;AuthController@refresh&apos;);</span><br><span class="line">    $api-&gt;post(&apos;me&apos;, &apos;AuthController@me&apos;);</span><br><span class="line">    $api-&gt;get(&apos;test&apos;, &apos;AuthController@test&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>设置了这几个路由，对应的url类似这样：<a href="http://www.yourweb.com/api/me" target="_blank" rel="noopener">http://www.yourweb.com/api/me</a> 使用postman来调试这些API。</p><h2 id="请求API的大致流程"><a href="#请求API的大致流程" class="headerlink" title="请求API的大致流程"></a>请求API的大致流程</h2><p>我们使用jwt代替session，首先是通过登录（jwt的attempt方法验证账号密码），成功后会返回一个JWT，我们把这个字符串统一叫做token,这个token需要我们客户端保存起来，然后后面需要认证的接口就在请求头里带上这个token，后台验证正确后就会进行下一操作，如果token错误，或者过期就返回401或500错误，拒绝后面的操作。</p><blockquote><p>前端可以保存在localStorage,小程序可以 使用wx.setStorageSync保存<br><a id="more"></a></p></blockquote><p>所以请求头信息Authorization:Bearer + token很重要，但是有个问题，这个token是有一个刷新时间和过期时间的:<br><code>&#39;ttl&#39; =&gt; env(&#39;JWT_TTL&#39;, 60),</code><br><code>&#39;refresh_ttl&#39; =&gt; env(&#39;JWT_REFRESH_TTL&#39;, 20160),</code></p><ul><li>refresh_ttl是过期时间，默认14天，很好理解，就像一些网站一样，你好几个月没去登录，你的账号会自动退出登录，因为过期了，需要重新输入账号密码登录。</li><li>ttl刷新时间默认60分钟，也就是说你拿这个一小时前的token去请求是不行的，会报The token has been blacklisted的错误，意思是说这个旧的token已经被列入黑名单，无法使用<blockquote><p>token是会被别人盗取的，所以token需要每隔一段时间就更新一次</p></blockquote></li></ul><p>这时候有个问题，每隔一小时就更新，那岂不是要每小时就重新登录一遍来获取新token？当然不需要，我们可以写个中间件来实现无痛刷新token,用户不会察觉我们已经更新了token。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Middleware</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Closure</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Exceptions</span>\<span class="title">JWTException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Http</span>\<span class="title">Middleware</span>\<span class="title">BaseMiddleware</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Exceptions</span>\<span class="title">TokenExpiredException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpKernel</span>\<span class="title">Exception</span>\<span class="title">UnauthorizedHttpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefreshToken</span> <span class="keyword">extends</span> <span class="title">BaseMiddleware</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: zhaogx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Closure $next</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse|\Illuminate\Http\Response|mixed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JWTException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($request, Closure $next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查此次请求中是否带有 token，如果没有则抛出异常。</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;checkForToken($request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 try 包裹，以捕捉 token 过期所抛出的 TokenExpiredException  异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检测用户的登录状态，如果正常则通过</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;auth-&gt;parseToken()-&gt;authenticate()) &#123;</span><br><span class="line">                <span class="keyword">return</span> $next($request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnauthorizedHttpException(<span class="string">'jwt-auth'</span>, <span class="string">'未登录'</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TokenExpiredException $exception) &#123;</span><br><span class="line">            <span class="comment">// 此处捕获到了 token 过期所抛出的 TokenExpiredException 异常，我们在这里需要做的是刷新该用户的 token 并将它添加到响应头中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 刷新用户的 token</span></span><br><span class="line">                $token = <span class="keyword">$this</span>-&gt;auth-&gt;refresh();</span><br><span class="line">                <span class="comment">// 使用一次性登录以保证此次请求的成功</span></span><br><span class="line">                \Auth::guard(<span class="string">'api'</span>)-&gt;onceUsingId(<span class="keyword">$this</span>-&gt;auth-&gt;manager()-&gt;getPayloadFactory()-&gt;buildClaimsCollection()-&gt;toPlainArray()[<span class="string">'sub'</span>]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JWTException $exception) &#123;</span><br><span class="line">                <span class="comment">// 如果捕获到此异常，即代表 refresh 也过期了，用户无法刷新令牌，需要重新登录。</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnauthorizedHttpException(<span class="string">'jwt-auth'</span>, $exception-&gt;getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $next($request)-&gt;withHeaders([</span><br><span class="line">                <span class="string">'Authorization'</span>=&gt; <span class="string">'Bearer '</span>.$token,</span><br><span class="line">            ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦中间件检测到token过时了，就自动刷新token，然后在响应头把新的token返回来，我们客户端可以根据响应头是否有’Authorization’来决定是否要替换token<br>在使用postman调试这些API的时候就有个问题，postman又没有前端代码，我怎么及时更新这个token,难道每次请求都要去看响应头，发现Authorization后手动去复制黏贴吗，当然也不需要，postman有个强大的环境变量，其实也是前端js的东西。</p><h2 id="postman自动刷新请求头token"><a href="#postman自动刷新请求头token" class="headerlink" title="postman自动刷新请求头token"></a>postman自动刷新请求头token</h2><h4 id="登录后自动获取token"><a href="#登录后自动获取token" class="headerlink" title="登录后自动获取token"></a>登录后自动获取token</h4><p>首先点击设置环境这个按钮，点击Add按钮添加一个变量，我们设置key值为access_token，<br><img src="/images/20181108/1.png" alt="1"><br><img src="/images/20181108/2.png" alt="2"><br>接着我们在登录接口的Tests中去赋值这个变量<br><img src="/images/20181108/3.png" alt="3"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var data = JSON.parse(responseBody);  </span><br><span class="line">if (data.result.access_token) &#123;  </span><br><span class="line">      tests[&quot;Body has token&quot;] = true;  </span><br><span class="line">      var tokenArray = data.result.access_token.split(&quot; &quot;);</span><br><span class="line">      postman.setEnvironmentVariable(&quot;access_token&quot;, tokenArray[1]);  </span><br><span class="line">&#125;  </span><br><span class="line">else &#123;  </span><br><span class="line">  tests[&quot;Body has token&quot;] = false;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段js代码就是获取请求成功后返回的access_token值，将其赋值给postman的环境变量，我们看到请求成功后我们后台返回了一个json,其中就有我们需要的access_token，我们可以再去环境变量那里看看这时候的变量有什么变化<br><img src="/images/20181108/4.png" alt="4"></p><p>可以看到这里的变量access_token已经有值了，就是我们后台返回来的access_token字符串，说明赋值成功</p><p>接着我们到另一个需要认证的接口测试<br>我们在Authorization类型type选择Bearer Token,在后面Token表单那里打一个’{‘就会自动提示我们设置过的变量<br><img src="/images/20181108/5.png" alt="5"><br>发送请求测试下<br><img src="/images/20181108/6.png" alt="6"><br>已经成功了。</p><h4 id="无痛刷新token"><a href="#无痛刷新token" class="headerlink" title="无痛刷新token"></a>无痛刷新token</h4><p>那如果token刷新了，经过后台中间件无痛刷新后，会在响应头返回一个新的token(这一次请求用的是旧的token,默认认证通过)<br><img src="/images/20181108/7.png" alt="7"><br>现在我们需要在这个接口上直接更新我们的变量access_token（如下图），而不需要去再请求一遍登录接口<br><img src="/images/20181108/8.png" alt="10"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var authHeader = postman.getResponseHeader(&apos;Authorization&apos;);</span><br><span class="line">if (authHeader)&#123;</span><br><span class="line">      var tokenArray = authHeader.split(&quot; &quot;);</span><br><span class="line">      postman.setEnvironmentVariable(&quot;access_token&quot;, tokenArray[1]);  </span><br><span class="line">      tests[&quot;Body has refreshtoken&quot;] = true;  </span><br><span class="line">&#125; else &#123;</span><br><span class="line">       tests[&quot;Body has no refreshtoken&quot;] = false;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段js代码就是将响应头中的Authorization赋值给我们的access_token</p><p><img src="/images/20181108/9.png" alt="8"><br>这是响应头的Authorization，截取了最后面的字符串<br><img src="/images/20181108/10.png" alt="9"></p><p>刷新时间过了后，我们试着再发一次请求，我们可以看到，还是可以访问的，而且请求头里的Authorization已经自动更新过来了</p><p>用一句话整理大概就是,你需要在哪个接口响应后更新变量,就去这个这个口的Test下写js赋值代码<br><code>postman.setEnvironmentVariable(&quot;access_token&quot;, token);</code>，只要没错误你就可以在别的地方使用更新替换了。</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇博客文章&lt;a href=&quot;https://zgxxx.github.io/2018/11/08/20181107/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zgxxx.github.io/2018/11/08/20181107/&lt;/a&gt; 介绍了laravel使用dingo+jwt开发API的几个步骤，那么在实际操作中，我们需要测试API&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$api = app(&amp;apos;Dingo\Api\Routing\Router&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$api-&amp;gt;version(&amp;apos;v1&amp;apos;, [&amp;apos;namespace&amp;apos; =&amp;gt; &amp;apos;App\Http\Controllers\V1&amp;apos;], function ($api) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;post(&amp;apos;register&amp;apos;, &amp;apos;AuthController@register&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;post(&amp;apos;login&amp;apos;, &amp;apos;AuthController@login&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;post(&amp;apos;logout&amp;apos;, &amp;apos;AuthController@logout&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;post(&amp;apos;refresh&amp;apos;, &amp;apos;AuthController@refresh&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;post(&amp;apos;me&amp;apos;, &amp;apos;AuthController@me&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    $api-&amp;gt;get(&amp;apos;test&amp;apos;, &amp;apos;AuthController@test&amp;apos;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置了这几个路由，对应的url类似这样：&lt;a href=&quot;http://www.yourweb.com/api/me&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.yourweb.com/api/me&lt;/a&gt; 使用postman来调试这些API。&lt;/p&gt;
&lt;h2 id=&quot;请求API的大致流程&quot;&gt;&lt;a href=&quot;#请求API的大致流程&quot; class=&quot;headerlink&quot; title=&quot;请求API的大致流程&quot;&gt;&lt;/a&gt;请求API的大致流程&lt;/h2&gt;&lt;p&gt;我们使用jwt代替session，首先是通过登录（jwt的attempt方法验证账号密码），成功后会返回一个JWT，我们把这个字符串统一叫做token,这个token需要我们客户端保存起来，然后后面需要认证的接口就在请求头里带上这个token，后台验证正确后就会进行下一操作，如果token错误，或者过期就返回401或500错误，拒绝后面的操作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前端可以保存在localStorage,小程序可以 使用wx.setStorageSync保存&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel修炼：服务容器绑定与解析</title>
    <link href="http://yoursite.com/2018/11/08/20181013/"/>
    <id>http://yoursite.com/2018/11/08/20181013/</id>
    <published>2018-11-08T12:21:37.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp; 老实说，第一次老大让我看laravel框架手册的那天早上，我是很绝望的，因为真的没接触过，对我这种渣渣来说，laravel的入门门槛确实有点高了，但还是得硬着头皮看下去（虽然到现在我还有很多没看懂，也没用过）。</p><p>&emsp; 后面慢慢根据公司项目的代码对laravel也慢慢熟悉起来了，但还是停留在一些表面的功能，例如依赖注入，ORM操作，用户认证这些和我项目业务逻辑相关的操作，然后对于一些架构基础的，例如服务提供器，服务容器，中间件，Redis等这些一开始就要设置好的东西，我倒是没实际操作过（因为老大一开始就做好了），所以看手册还是有点懵。</p><p>&emsp; 所以有空的时候逛逛论坛，搜下Google就发现许多关于laravel核心架构的介绍，以及如何使用的网站（确实看完后再去看手册就好理解多了），下面就根据一个我觉得不错的网站上面的教学来记录一下laravel核心架构的学习<br>网站地址：<a href="https://laraweb.net/" target="_blank" rel="noopener">https://laraweb.net/</a> 这是一个日本的网站，我觉得挺适合新手的，内容用浏览器翻译过来就ok了，毕竟日文直翻过来很好理解的</p><a id="more"></a><h2 id="关于服务容器"><a href="#关于服务容器" class="headerlink" title="关于服务容器"></a>关于服务容器</h2><p>&emsp; 手册上是这样介绍的：Laravel 服务容器是用于管理类的依赖和执行依赖注入的工具。依赖注入这个花俏名词实质上是指：类的依赖项通过构造函数，或者某些情况下通过「setter」方法「注入」到类中。。。。。。（真的看不懂啥意思）</p><p>&emsp; 服务容器是用于管理类（服务）的实例化的机制。直接看看服务容器怎么用</p><p>&emsp; 1.在服务容器中注册类（bind）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">$this</span>-&gt;app-&gt;bind(<span class="string">'sender'</span>,<span class="string">'MailSender'</span>);</span><br><span class="line"><span class="comment">//$this-&gt;app成为服务容器。</span></span><br></pre></td></tr></table></figure><p>&emsp; 2.从服务容器生成类（make）<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$sender = <span class="keyword">$this</span>-&gt;app-&gt;make(<span class="string">'sender'</span>);</span><br><span class="line"><span class="comment">//从服务容器（$this-&gt;app）创建一个sender类。</span></span><br><span class="line">在这种情况下，将返回MailSender的实例。</span><br></pre></td></tr></table></figure></p><p>&emsp; 这是服务容器最简单的使用，下面是对服务容器的详细介绍（主要参考：<a href="https://www.cnblogs.com/lyzg/p/6181055.html#_label2）" target="_blank" rel="noopener">https://www.cnblogs.com/lyzg/p/6181055.html#_label2）</a></p><h3 id="laravel容器基本认识"><a href="#laravel容器基本认识" class="headerlink" title="laravel容器基本认识"></a>laravel容器基本认识</h3><p>&emsp; 一开始，index.php 文件加载 Composer 生成定义的自动加载器，然后从 bootstrap/app.php 脚本中检索 Laravel 应用程序的实例。Laravel 本身采取的第一个动作是创建一个 application/ service container 的实例。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$app = <span class="keyword">new</span> Illuminate\Foundation\Application(</span><br><span class="line">    dirname(<span class="keyword">__DIR__</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>&emsp; 这个文件在每一次请求到达laravel框架都会执行，所创建的$app即是laravel框架的应用程序实例，它在整个请求生命周期都是唯一的。laravel提供了很多服务，包括认证，数据库，缓存，消息队列等等，$app作为一个容器管理工具，负责几乎所有服务组件的实例化以及实例的生命周期管理。当需要一个服务类来完成某个功能的时候，仅需要通过容器解析出该类型的一个实例即可。从最终的使用方式来看，laravel容器对服务实例的管理主要包括以下几个方面：</p><ul><li><strong>服务的绑定与解析</strong></li><li><strong>服务提供者的管理</strong></li><li><strong>别名的作用</strong></li><li><strong>依赖注入</strong></li></ul><p>先了解如何在代码中获取到容器实例，再学习上面四个关键</p><h4 id="如何在代码中获取到容器实例"><a href="#如何在代码中获取到容器实例" class="headerlink" title="如何在代码中获取到容器实例"></a>如何在代码中获取到容器实例</h4><p>第一种是<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$app = app();</span><br><span class="line"><span class="comment">//app这个辅助函数定义在\vendor\laravel\framework\src\Illuminate\Foundation\helper.php</span></span><br><span class="line">里面，，这个文件定义了很多help函数，并且会通过composer自动加载到项目中。</span><br><span class="line">所以，在参与http请求处理的任何代码位置都能够访问其中的函数，比如app()。</span><br></pre></td></tr></table></figure></p><p>第二种是<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Route::get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    dd(App::basePath());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这个其实是用到Facade，中文直译貌似叫门面，在config/app.php中，</span></span><br><span class="line">有一节数组aliases专门用来配置一些类型的别名，第一个就是<span class="string">'App'</span> =&gt; Illuminate\Support\Facades\App::class,</span><br><span class="line">具体的Google一下laravel有关门面的具体实现方式</span><br></pre></td></tr></table></figure></p><p>第三种是</p><p>&emsp; 在服务提供者里面直接使用$this-&gt;app。服务提供者后面还会介绍，现在只是引入。因为服务提供者类都是由laravel容器实例化的，这些类都继承自Illuminate\Support\ServiceProvider，它定义了一个实例属性$app：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProvider</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $app;</span><br></pre></td></tr></table></figure></p><p>&emsp; laravel在实例化服务提供者的时候，会把laravel容器实例注入到这个$app上面。所以我们在服务提供者里面，始终能通过$this-&gt;$app访问到laravel容器实例，而不需要再使用app()函数或者App Facade了。</p><h4 id="如何理解服务绑定与解析"><a href="#如何理解服务绑定与解析" class="headerlink" title="如何理解服务绑定与解析"></a>如何理解服务绑定与解析</h4><p>&emsp; 浅义层面理解，容器既然用来存储对象，那么就要有一个对象存入跟对象取出的过程。这个对象存入跟对象取出的过程在laravel里面称为服务的绑定与解析。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">app()-&gt;bind(<span class="string">'service'</span>, <span class="string">'this is service1'</span>);</span><br><span class="line"></span><br><span class="line">app()-&gt;bind(<span class="string">'service2'</span>, [</span><br><span class="line">    <span class="string">'hi'</span> =&gt; <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//say hi</span></span><br><span class="line">    &#125;</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app()-&gt;bind(<span class="string">'service3'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Service();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>&emsp; 还有一个单例绑定singleton，是bind的一种特殊情况（第三个参数为true）,绑定到容器的对象只会被解析一次，之后的调用都返回相同的实例<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">singleton</span><span class="params">($abstract, $concrete = null)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">$this</span>-&gt;bind($abstract, $concrete, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp; 在绑定的时候，我们可以直接绑定已经初始化好的数据（基本类型、数组、对象实例），还可以用匿名函数来绑定。用匿名函数的好处在于，这个服务绑定到容器以后，并不会立即产生服务最终的对象，只有在这个服务解析的时候，匿名函数才会执行，此时才会产生这个服务对应的服务实例。</p><p>&emsp; 实际上，当我们使用singleton，bind方法以及数组形式，（这三个方法是后面要介绍的绑定的方法），进行服务绑定的时候，如果绑定的服务形式，不是一个匿名函数，也会在laravel内部用一个匿名函数包装起来，这样的话， 不轮绑定什么内容，都能做到前面介绍的懒初始化的功能，这对于容器的性能是有好处的。这个可以从bind的源码中看到一些细节：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! $concrete <span class="keyword">instanceof</span> Closure) &#123;</span><br><span class="line">    $concrete = <span class="keyword">$this</span>-&gt;getClosure($abstract, $concrete);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看看bind的底层代码<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span><span class="params">($abstract, $concrete = null, $shared = false)</span></span></span><br></pre></td></tr></table></figure></p><p>&emsp; 第一个参数服务绑定名称，第二个参数服务绑定的结果（也就是闭包，得到实例），第三个参数就表示这个服务是否在多次解析的时候，始终返回第一次解析出的实例（也就是单例绑定singleton）。</p><p>&emsp; 服务绑定还可以通过数组的方式：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app()[<span class="string">'service'</span>] = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Service();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>绑定大概就这些，接下来看解析，也就是取出来用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$service= app()-&gt;make(<span class="string">'service'</span>);</span><br></pre></td></tr></table></figure><p>&emsp; 这个方法接收两个参数，第一个是服务的绑定名称和服务绑定名称的别名，如果是别名，那么就会根据服务绑定名称的别名配置，找到最终的服务绑定名称，然后进行解析；第二个参数是一个数组，最终会传递给服务绑定产生的闭包。</p><p>看源码：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolve the given type from the container.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $abstract</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array  $parameters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">make</span><span class="params">($abstract, array $parameters = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;resolve($abstract, $parameters);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolve the given type from the container.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $abstract</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  array  $parameters</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">resolve</span><span class="params">($abstract, $parameters = [])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $abstract = <span class="keyword">$this</span>-&gt;getAlias($abstract);</span><br><span class="line"></span><br><span class="line">    $needsContextualBuild = ! <span class="keyword">empty</span>($parameters) || ! is_null(</span><br><span class="line">        <span class="keyword">$this</span>-&gt;getContextualConcrete($abstract)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If an instance of the type is currently being managed as a singleton we'll</span></span><br><span class="line">    <span class="comment">// just return an existing instance instead of instantiating new instances</span></span><br><span class="line">    <span class="comment">// so the developer can keep using the same objects instance every time.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;instances[$abstract];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;with[] = $parameters;</span><br><span class="line"></span><br><span class="line">    $concrete = <span class="keyword">$this</span>-&gt;getConcrete($abstract);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We're ready to instantiate an instance of the concrete type registered for</span></span><br><span class="line">    <span class="comment">// the binding. This will instantiate the types, as well as resolve any of</span></span><br><span class="line">    <span class="comment">// its "nested" dependencies recursively until all have gotten resolved.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isBuildable($concrete, $abstract)) &#123;</span><br><span class="line">        $object = <span class="keyword">$this</span>-&gt;build($concrete);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        $object = <span class="keyword">$this</span>-&gt;make($concrete);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we defined any extenders for this type, we'll need to spin through them</span></span><br><span class="line">    <span class="comment">// and apply them to the object being built. This allows for the extension</span></span><br><span class="line">    <span class="comment">// of services, such as changing configuration or decorating the object.</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">$this</span>-&gt;getExtenders($abstract) <span class="keyword">as</span> $extender) &#123;</span><br><span class="line">        $object = $extender($object, <span class="keyword">$this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the requested type is registered as a singleton we'll want to cache off</span></span><br><span class="line">    <span class="comment">// the instances in "memory" so we can return it later without creating an</span></span><br><span class="line">    <span class="comment">// entirely new instance of an object on each subsequent request for it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;instances[$abstract] = $object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;fireResolvingCallbacks($abstract, $object);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before returning, we will also set the resolved flag to "true" and pop off</span></span><br><span class="line">    <span class="comment">// the parameter overrides for this build. After those two things are done</span></span><br><span class="line">    <span class="comment">// we will be ready to return back the fully constructed class instance.</span></span><br><span class="line">    <span class="keyword">$this</span>-&gt;resolved[$abstract] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    array_pop(<span class="keyword">$this</span>-&gt;with);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一步：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$needsContextualBuild = ! <span class="keyword">empty</span>($parameters) || ! is_null(</span><br><span class="line">    <span class="keyword">$this</span>-&gt;getContextualConcrete($abstract)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>&emsp; 该方法主要是区分，解析的对象是否有参数，如果有参数，还需要对参数做进一步的分析，因为传入的参数，也可能是依赖注入的，所以还需要对传入的参数进行解析；这个后面再分析。</p><p>第二步：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;instances[$abstract];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp; 如果是绑定的单例，并且不需要上面的参数依赖。我们就可以直接返回 $this-&gt;instances[$abstract]。</p><p>第三步：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$concrete = <span class="keyword">$this</span>-&gt;getConcrete($abstract);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the concrete type for a given abstract.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $abstract</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed   $concrete</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">getConcrete</span><span class="params">($abstract)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (! is_null($concrete = <span class="keyword">$this</span>-&gt;getContextualConcrete($abstract))) &#123;</span><br><span class="line">        <span class="keyword">return</span> $concrete;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't have a registered resolver or concrete for the type, we'll just</span></span><br><span class="line">    <span class="comment">// assume each type is a concrete name and will attempt to resolve it as is</span></span><br><span class="line">    <span class="comment">// since the container should be able to resolve concretes automatically.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;bindings[$abstract])) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;bindings[$abstract][<span class="string">'concrete'</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $abstract;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp; 这一步主要是先从绑定的上下文找，是不是可以找到绑定类；如果没有，则再从 $bindings[] 中找关联的实现类；最后还没有找到的话，就直接返回 $abstract 本身。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// We're ready to instantiate an instance of the concrete type registered for</span></span><br><span class="line"><span class="comment">// the binding. This will instantiate the types, as well as resolve any of</span></span><br><span class="line"><span class="comment">// its "nested" dependencies recursively until all have gotten resolved.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;isBuildable($concrete, $abstract)) &#123;</span><br><span class="line">    $object = <span class="keyword">$this</span>-&gt;build($concrete);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $object = <span class="keyword">$this</span>-&gt;make($concrete);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine if the given concrete is buildable.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  mixed   $concrete</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $abstract</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">isBuildable</span><span class="params">($concrete, $abstract)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> $concrete === $abstract || $concrete <span class="keyword">instanceof</span> Closure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp; 如果之前找到的 $concrete 返回的是 $abstract 值，或者 $concrete 是个闭包，则执行 $this-&gt;build($concrete)，否则，表示存在嵌套依赖的情况，则采用递归的方法执行 $this-&gt;make($concrete)，直到所有的都解析完为止。</p><p><em>$this-&gt;build($concrete)</em></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Instantiate a concrete instance of the given type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  string  $concrete</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> \Illuminate\Contracts\Container\BindingResolutionException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">build</span><span class="params">($concrete)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// If the concrete type is actually a Closure, we will just execute it and</span></span><br><span class="line">    <span class="comment">// hand back the results of the functions, which allows functions to be</span></span><br><span class="line">    <span class="comment">// used as resolvers for more fine-tuned resolution of these objects.</span></span><br><span class="line">    <span class="comment">// 如果传入的是闭包，则直接执行闭包函数，返回结果</span></span><br><span class="line">    <span class="keyword">if</span> ($concrete <span class="keyword">instanceof</span> Closure) &#123;</span><br><span class="line">        <span class="keyword">return</span> $concrete(<span class="keyword">$this</span>, <span class="keyword">$this</span>-&gt;getLastParameterOverride());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 利用反射机制，解析该类。</span></span><br><span class="line">    $reflector = <span class="keyword">new</span> ReflectionClass($concrete);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the type is not instantiable, the developer is attempting to resolve</span></span><br><span class="line">    <span class="comment">// an abstract type such as an Interface of Abstract Class and there is</span></span><br><span class="line">    <span class="comment">// no binding registered for the abstractions so we need to bail out.</span></span><br><span class="line">    <span class="keyword">if</span> (! $reflector-&gt;isInstantiable()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;notInstantiable($concrete);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">$this</span>-&gt;buildStack[] = $concrete;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取构造函数</span></span><br><span class="line">    $constructor = $reflector-&gt;getConstructor();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there are no constructors, that means there are no dependencies then</span></span><br><span class="line">    <span class="comment">// we can just resolve the instances of the objects right away, without</span></span><br><span class="line">    <span class="comment">// resolving any other types or dependencies out of these containers.</span></span><br><span class="line">    <span class="comment">// 如果没有构造函数，则表明没有传入参数，也就意味着不需要做对应的上下文依赖解析。</span></span><br><span class="line">    <span class="keyword">if</span> (is_null($constructor)) &#123;</span><br><span class="line">        <span class="comment">// 将 build 过程的内容 pop，然后直接构造对象输出。</span></span><br><span class="line">        array_pop(<span class="keyword">$this</span>-&gt;buildStack);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> $concrete;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取构造函数的参数</span></span><br><span class="line">    $dependencies = $constructor-&gt;getParameters();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Once we have all the constructor's parameters we can create each of the</span></span><br><span class="line">    <span class="comment">// dependency instances and then use the reflection instances to make a</span></span><br><span class="line">    <span class="comment">// new instance of this class, injecting the created dependencies in.</span></span><br><span class="line">    <span class="comment">// 解析出所有上下文依赖对象，带入函数，构造对象输出</span></span><br><span class="line">    $instances = <span class="keyword">$this</span>-&gt;resolveDependencies(</span><br><span class="line">        $dependencies</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    array_pop(<span class="keyword">$this</span>-&gt;buildStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> $reflector-&gt;newInstanceArgs($instances);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这一段有关解析make的介绍主要参考：<br><a href="https://juejin.im/post/5b012f796fb9a07ace5925be" target="_blank" rel="noopener">coding01:看 Laravel 源代码了解 Container</a></p><p>&emsp; 这一篇就主要学习laravel的服务容器以及它的绑定和解析，虽然目前能力无法对框架源码每一个地方都弄懂，但通过这几篇优秀的文章，我将其进行整理结合，这过程让我更加理解laravel的一些核心内容，起码别人问起来我多多少少能说出一些，这就是进步。</p><p>&emsp; 后面有关服务提供者，依赖注入，中间件等内容的学习将放在后续的博客文章中</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp; 老实说，第一次老大让我看laravel框架手册的那天早上，我是很绝望的，因为真的没接触过，对我这种渣渣来说，laravel的入门门槛确实有点高了，但还是得硬着头皮看下去（虽然到现在我还有很多没看懂，也没用过）。&lt;/p&gt;
&lt;p&gt;&amp;emsp; 后面慢慢根据公司项目的代码对laravel也慢慢熟悉起来了，但还是停留在一些表面的功能，例如依赖注入，ORM操作，用户认证这些和我项目业务逻辑相关的操作，然后对于一些架构基础的，例如服务提供器，服务容器，中间件，Redis等这些一开始就要设置好的东西，我倒是没实际操作过（因为老大一开始就做好了），所以看手册还是有点懵。&lt;/p&gt;
&lt;p&gt;&amp;emsp; 所以有空的时候逛逛论坛，搜下Google就发现许多关于laravel核心架构的介绍，以及如何使用的网站（确实看完后再去看手册就好理解多了），下面就根据一个我觉得不错的网站上面的教学来记录一下laravel核心架构的学习&lt;br&gt;网站地址：&lt;a href=&quot;https://laraweb.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://laraweb.net/&lt;/a&gt; 这是一个日本的网站，我觉得挺适合新手的，内容用浏览器翻译过来就ok了，毕竟日文直翻过来很好理解的&lt;/p&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>laravel5.5+dingo+JWT开发后台API</title>
    <link href="http://yoursite.com/2018/11/08/20181107/"/>
    <id>http://yoursite.com/2018/11/08/20181107/</id>
    <published>2018-11-08T12:21:37.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>dingo api 中文文档： <a href="https://www.bookstack.cn/read/dingo-api-wiki-zh/README.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/dingo-api-wiki-zh/README.md</a><br>Laravel中使用JWT：<a href="https://laravel-china.org/articles/10885/full-use-of-jwt" target="_blank" rel="noopener">https://laravel-china.org/articles/10885/full-use-of-jwt</a><br>辅助文章：               <a href="https://www.jianshu.com/p/62b0c4d75e59" target="_blank" rel="noopener">https://www.jianshu.com/p/62b0c4d75e59</a></p><blockquote><p>参考<a href="https://www.jianshu.com/p/62b0c4d75e59" target="_blank" rel="noopener">https://www.jianshu.com/p/62b0c4d75e59</a> 这篇文章基本就能搭建出环境，我使用的版本跟他一样 “dingo/api”: “2.0.0-alpha1”,”tymon/jwt-auth”: “^1.0.0-rc.1”，不知道别的版本有啥大的区别，但是网上找的其他一些文章使用的是旧的版本，jwt封装的东西路径可能不一样，可能会保错，有些文档还说要手动添加Tymon\JWTAuth\Providers\LaravelServiceProvider::class和Dingo\Api\Provider\LaravelServiceProvider::class，其实新版本不需要。<br><a id="more"></a></p></blockquote><h3 id="1-composer-json引入包-执行composer-update："><a href="#1-composer-json引入包-执行composer-update：" class="headerlink" title="1.   composer.json引入包,执行composer update："></a>1.   composer.json引入包,执行composer update：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="string">"require"</span>: &#123;</span><br><span class="line">......</span><br><span class="line">   <span class="string">"dingo/api"</span>: <span class="string">"2.0.0-alpha1"</span>,</span><br><span class="line">   <span class="string">"tymon/jwt-auth"</span>: <span class="string">"^1.0.0-rc.1"</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="2-执行下面两个语句自动生成dingo和jwt的配置文件："><a href="#2-执行下面两个语句自动生成dingo和jwt的配置文件：" class="headerlink" title="2.  执行下面两个语句自动生成dingo和jwt的配置文件："></a>2.  执行下面两个语句自动生成dingo和jwt的配置文件：</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php artisan vendor:publish --provider=<span class="string">"Dingo\Api\Provider\LaravelServiceProvider"</span></span><br><span class="line"><span class="comment">//config文件夹中生成dingo配置文件---&gt; api.php</span></span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">php artisan vendor:publish --provider=<span class="string">"Tymon\JWTAuth\Providers\LaravelServiceProvider"</span></span><br><span class="line"><span class="comment">//config文件夹中生成dingo配置文件---&gt; jwt.php</span></span><br></pre></td></tr></table></figure><h3 id="3-配置-env"><a href="#3-配置-env" class="headerlink" title="3.  配置 .env"></a>3.  配置 .env</h3><p>具体配置可参考 文档<a href="https://www.bookstack.cn/read/dingo-api-wiki-zh/Configuration.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/dingo-api-wiki-zh/Configuration.md</a> ，我的配置是<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">API_STANDARDS_TREE=vnd</span><br><span class="line">API_PREFIX=api</span><br><span class="line">API_VERSION=v1</span><br><span class="line">API_DEBUG=<span class="keyword">true</span></span><br><span class="line">API_SUBTYPE=myapp</span><br></pre></td></tr></table></figure></p><p>还需在命令行执行 <code>php artisan jwt:secret</code>，会在.env自动添加JWT_SECRET，其他若需要，可以到各种的配置文件中看，在.env添加即可</p><h3 id="4-关键处理"><a href="#4-关键处理" class="headerlink" title="4.  关键处理"></a>4.  关键处理</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'defaults'</span> =&gt; [</span><br><span class="line">        <span class="string">'guard'</span> =&gt; <span class="string">'web'</span>,</span><br><span class="line">        <span class="string">'passwords'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="string">'guards'</span> =&gt; [</span><br><span class="line">        <span class="string">'web'</span> =&gt; [</span><br><span class="line">            <span class="string">'driver'</span> =&gt; <span class="string">'session'</span>,</span><br><span class="line">            <span class="string">'provider'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        <span class="string">'api'</span> =&gt; [</span><br><span class="line">            <span class="string">'driver'</span> =&gt; <span class="string">'jwt'</span>, </span><br><span class="line">            <span class="string">'provider'</span> =&gt; <span class="string">'users'</span>,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure><p>这里需要把api原本的driver =&gt; session 改为使用jwt机制，provider对应你要用的用户认证表，一般就是登录注册那张表</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Models</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Contracts</span>\<span class="title">JWTSubject</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Notifications</span>\<span class="title">Notifiable</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Foundation</span>\<span class="title">Auth</span>\<span class="title">User</span> <span class="title">as</span> <span class="title">Authenticatable</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Authenticatable</span> <span class="keyword">implements</span> <span class="title">JWTSubject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">Notifiable</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The attributes that are mass assignable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $fillable = [</span><br><span class="line">        <span class="string">'name'</span>, <span class="string">'email'</span>, <span class="string">'password'</span>, <span class="string">'unionid'</span></span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The attributes that should be hidden for arrays.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> $hidden = [</span><br><span class="line">        <span class="string">'password'</span>, <span class="string">'remember_token'</span>,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rest omitted for brevity</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the identifier that will be stored in the subject claim of the JWT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJWTIdentifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a key value array, containing any custom claims to be added to the JWT.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getJWTCustomClaims</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-设置控制器"><a href="#5-设置控制器" class="headerlink" title="5.  设置控制器"></a>5.  设置控制器</h3><p>考虑到可能后面需要开发不同版本api，所以在app/Http/Controller下建立了V1，V2目录，根据你自己的需求来，只要写好命名空间就ok <img src="https://upload.cc/i1/2018/11/07/rvytHT.png" alt="avatar"></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Date: 17/10/12</span></span><br><span class="line"><span class="comment"> * Time: 01:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">V1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Controllers</span>\<span class="title">Controller</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Http</span>\<span class="title">Request</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">Facades</span>\<span class="title">Auth</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Validator</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">App</span>\<span class="title">User</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthController</span> <span class="keyword">extends</span> <span class="title">Controller</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> $guard = <span class="string">'api'</span>;<span class="comment">//设置使用guard为api选项验证，请查看config/auth.php的guards设置项，重要！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Create a new AuthController instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;middleware(<span class="string">'refresh'</span>, [<span class="string">'except'</span> =&gt; [<span class="string">'login'</span>,<span class="string">'register'</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"test!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        $rules = [</span><br><span class="line">            <span class="string">'name'</span> =&gt; [<span class="string">'required'</span>],</span><br><span class="line">            <span class="string">'email'</span> =&gt; [<span class="string">'required'</span>],</span><br><span class="line">            <span class="string">'password'</span> =&gt; [<span class="string">'required'</span>, <span class="string">'min:6'</span>, <span class="string">'max:16'</span>],</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        $payload = $request-&gt;only(<span class="string">'name'</span>, <span class="string">'email'</span>, <span class="string">'password'</span>);</span><br><span class="line">        $validator = Validator::make($payload, $rules);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 验证格式</span></span><br><span class="line">        <span class="keyword">if</span> ($validator-&gt;fails()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;array([<span class="string">'error'</span> =&gt; $validator-&gt;errors()]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建用户</span></span><br><span class="line">        $result = User::create([</span><br><span class="line">            <span class="string">'name'</span> =&gt; $payload[<span class="string">'name'</span>],</span><br><span class="line">            <span class="string">'email'</span> =&gt; $payload[<span class="string">'email'</span>],</span><br><span class="line">            <span class="string">'password'</span> =&gt; bcrypt($payload[<span class="string">'password'</span>]),</span><br><span class="line">        ]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($result) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;array([<span class="string">'success'</span> =&gt; <span class="string">'创建用户成功'</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;array([<span class="string">'error'</span> =&gt; <span class="string">'创建用户失败'</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get a JWT token via given credentials.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  \Illuminate\Http\Request  $request</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span><span class="params">(Request $request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $credentials = $request-&gt;only(<span class="string">'email'</span>, <span class="string">'password'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($token = <span class="keyword">$this</span>-&gt;guard()-&gt;attempt($credentials)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;respondWithToken($token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;errorUnauthorized(<span class="string">'登录失败'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the authenticated User</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">me</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//return response()-&gt;json($this-&gt;guard()-&gt;user());</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;array(<span class="keyword">$this</span>-&gt;guard()-&gt;user());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Log the user out (Invalidate the token)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">logout</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;guard()-&gt;logout();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//return response()-&gt;json(['message' =&gt; 'Successfully logged out']);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;response-&gt;array([<span class="string">'message'</span> =&gt; <span class="string">'退出成功'</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Refresh a token.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">refresh</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;respondWithToken(<span class="keyword">$this</span>-&gt;guard()-&gt;refresh());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the token array structure.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  string $token</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">function</span> <span class="title">respondWithToken</span><span class="params">($token)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> response()-&gt;json([</span><br><span class="line">            <span class="string">'access_token'</span> =&gt; $token,</span><br><span class="line">            <span class="string">'token_type'</span> =&gt; <span class="string">'bearer'</span>,</span><br><span class="line">            <span class="string">'expires_in'</span> =&gt; <span class="keyword">$this</span>-&gt;guard()-&gt;factory()-&gt;getTTL() * <span class="number">60</span></span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get the guard to be used during authentication.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Contracts\Auth\Guard</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">guard</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Auth::guard(<span class="keyword">$this</span>-&gt;guard);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>控制器中命名空间namespace需要设置好，路由的时候需要用到，<br><code>$this-&gt;middleware(&#39;refresh&#39;, [&#39;except&#39; =&gt; [&#39;login&#39;,&#39;register&#39;]]);</code><br>这里的中间件使用的是网上找的，用于无痛刷新jwt的token,具体可以参考这篇文章：<a href="https://www.jianshu.com/p/9e95a5f8ac4a" target="_blank" rel="noopener">https://www.jianshu.com/p/9e95a5f8ac4a</a></p></blockquote><h3 id="6-refresh中间件"><a href="#6-refresh中间件" class="headerlink" title="6. refresh中间件"></a>6. refresh中间件</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Http</span>\<span class="title">Middleware</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Closure</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Exceptions</span>\<span class="title">JWTException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Http</span>\<span class="title">Middleware</span>\<span class="title">BaseMiddleware</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Tymon</span>\<span class="title">JWTAuth</span>\<span class="title">Exceptions</span>\<span class="title">TokenExpiredException</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Symfony</span>\<span class="title">Component</span>\<span class="title">HttpKernel</span>\<span class="title">Exception</span>\<span class="title">UnauthorizedHttpException</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefreshToken</span> <span class="keyword">extends</span> <span class="title">BaseMiddleware</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span>: zhaogx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Closure $next</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> \Illuminate\Http\JsonResponse|\Illuminate\Http\Response|mixed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JWTException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">handle</span><span class="params">($request, Closure $next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 检查此次请求中是否带有 token，如果没有则抛出异常。</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;checkForToken($request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 try 包裹，以捕捉 token 过期所抛出的 TokenExpiredException  异常</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检测用户的登录状态，如果正常则通过</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;auth-&gt;parseToken()-&gt;authenticate()) &#123;</span><br><span class="line">                <span class="keyword">return</span> $next($request);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnauthorizedHttpException(<span class="string">'jwt-auth'</span>, <span class="string">'未登录'</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TokenExpiredException $exception) &#123;</span><br><span class="line">            <span class="comment">// 此处捕获到了 token 过期所抛出的 TokenExpiredException 异常，我们在这里需要做的是刷新该用户的 token 并将它添加到响应头中</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 刷新用户的 token</span></span><br><span class="line">                $token = <span class="keyword">$this</span>-&gt;auth-&gt;refresh();</span><br><span class="line">                <span class="comment">// 使用一次性登录以保证此次请求的成功</span></span><br><span class="line">                \Auth::guard(<span class="string">'api'</span>)-&gt;onceUsingId(<span class="keyword">$this</span>-&gt;auth-&gt;manager()-&gt;getPayloadFactory()-&gt;buildClaimsCollection()-&gt;toPlainArray()[<span class="string">'sub'</span>]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JWTException $exception) &#123;</span><br><span class="line">                <span class="comment">// 如果捕获到此异常，即代表 refresh 也过期了，用户无法刷新令牌，需要重新登录。</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnauthorizedHttpException(<span class="string">'jwt-auth'</span>, $exception-&gt;getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $next($request)-&gt;withHeaders([</span><br><span class="line">                <span class="string">'Authorization'</span>=&gt; <span class="string">'Bearer '</span>.$token,</span><br><span class="line">            ]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>写好中间件后需要在app/Http/Kernel.php中注入<br> protected $routeMiddleware = [<br>   ​    ……<br>   ​    ‘refresh’ =&gt; RefreshToken::class,<br>  ];</p></blockquote><h3 id="7-routes-api-php-设置路由"><a href="#7-routes-api-php-设置路由" class="headerlink" title="7.  routes/api.php 设置路由"></a>7.  routes/api.php 设置路由</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$api = app(<span class="string">'Dingo\Api\Routing\Router'</span>);</span><br><span class="line">$api-&gt;version(<span class="string">'v1'</span>, [<span class="string">'namespace'</span> =&gt; <span class="string">'App\Http\Controllers\V1'</span>], <span class="function"><span class="keyword">function</span> <span class="params">($api)</span> </span>&#123;</span><br><span class="line">    $api-&gt;post(<span class="string">'register'</span>, <span class="string">'AuthController@register'</span>);</span><br><span class="line">    $api-&gt;post(<span class="string">'login'</span>, <span class="string">'AuthController@login'</span>);</span><br><span class="line">    $api-&gt;post(<span class="string">'logout'</span>, <span class="string">'AuthController@logout'</span>);</span><br><span class="line">    $api-&gt;post(<span class="string">'refresh'</span>, <span class="string">'AuthController@refresh'</span>);</span><br><span class="line">    $api-&gt;post(<span class="string">'me'</span>, <span class="string">'AuthController@me'</span>);</span><br><span class="line">    $api-&gt;get(<span class="string">'test'</span>, <span class="string">'AuthController@test'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>这里有个坑，不要这样写$api-&gt;post(‘me’,[‘middleware’ =&gt;’refresh’], ‘AuthController@me’);<br>这样虽然能执行这个中间件但执行到$next($request)这里会出错，貌似是一个回调报错 Function name must be a string ，不太清楚具体原因，可以这样写$api-&gt;post(‘me’,, ‘AuthController@me’)-&gt;middleware(‘refresh’);</p></blockquote><p>根据以上几个步骤就可以建立起简单的api后台基础，获取api路由列表可以使用命令行：<br><code>php artisan api:routes</code><br>routes:list貌似无法显示以上api路由，需要在api.php那里再写一遍原始的laravel路由定义才可以显示：比如这样Route::post(‘api/test’, ‘AuthController@test’);后续会用另一篇幅来记录postman和小程序相关知识</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dingo api 中文文档： &lt;a href=&quot;https://www.bookstack.cn/read/dingo-api-wiki-zh/README.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.bookstack.cn/read/dingo-api-wiki-zh/README.md&lt;/a&gt;&lt;br&gt;Laravel中使用JWT：&lt;a href=&quot;https://laravel-china.org/articles/10885/full-use-of-jwt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://laravel-china.org/articles/10885/full-use-of-jwt&lt;/a&gt;&lt;br&gt;辅助文章：               &lt;a href=&quot;https://www.jianshu.com/p/62b0c4d75e59&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/62b0c4d75e59&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考&lt;a href=&quot;https://www.jianshu.com/p/62b0c4d75e59&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/62b0c4d75e59&lt;/a&gt; 这篇文章基本就能搭建出环境，我使用的版本跟他一样 “dingo/api”: “2.0.0-alpha1”,”tymon/jwt-auth”: “^1.0.0-rc.1”，不知道别的版本有啥大的区别，但是网上找的其他一些文章使用的是旧的版本，jwt封装的东西路径可能不一样，可能会保错，有些文档还说要手动添加Tymon\JWTAuth\Providers\LaravelServiceProvider::class和Dingo\Api\Provider\LaravelServiceProvider::class，其实新版本不需要。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Laravel修炼：服务提供者</title>
    <link href="http://yoursite.com/2018/10/27/20181027/"/>
    <id>http://yoursite.com/2018/10/27/20181027/</id>
    <published>2018-10-27T14:33:05.000Z</published>
    <updated>2019-01-18T13:05:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp; 上一篇博客文章收集了关于Laravel服务容器的相关知识（<a href="https://zgxxx.github.io/2018/10/14/20181013/" target="_blank" rel="noopener">传送门</a>），我们知道了服务容器主要有绑定和解析两个重要功能，那么Laravel这个框架集齐了如此多功能，我们项目可能还需要另外引入一些功能包，这些绑定必须有一个统一的管理工具，统一绑定在一个地方，这个地方就是服务提供者。</p><h2 id="关于服务提供者"><a href="#关于服务提供者" class="headerlink" title="关于服务提供者"></a>关于服务提供者</h2><p>&emsp; 一开始学Laravel被服务容器和服务提供者两个名称搞混了，其实现在我是这样理解：容器就是底层一个大桶， 我们需要很多材料往里面填充，而提供者就是一些管道，我们就是通过提供者往容器里面塞我们需要的东西，需要的服务。</p><p>&emsp; Laravel有一种机制来定义和执行每个服务的初始处理，实现初始处理的类称为<strong>服务提供者</strong>。 </p><p>&emsp; 服务提供者，在laravel里面，其实就是一个工厂类。它最大的作用就是用来进行服务绑定。当我们需要绑定一个或多个服务的时候，可以自定义一个服务提供者，然后把服务绑定的逻辑都放在该类的实现中。在larave里面，要自定一个服务提供者非常容易，只要继承Illuminate\Support\ServiceProvider这个类即可。下面通过一个简单的自定义服务提供者来说明服务提供者的一些要点：<br><a id="more"></a><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">App</span>\<span class="title">Providers</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Illuminate</span>\<span class="title">Support</span>\<span class="title">ServiceProvider</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">yourServiceProvider</span> <span class="keyword">extends</span> <span class="title">ServiceProvider</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> $defer = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">boot</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">register</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">'service1'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'service1'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">'service2'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'service2'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;app-&gt;singleton(<span class="string">'service3'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'service3'</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="function"><span class="keyword">function</span> <span class="title">provides</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'service1'</span>,<span class="string">'service2'</span>,<span class="string">'service3'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于服务提供者类可以通过artisan命令创建：<br><code>php artisan make:provider yourServiceProvider</code><br>创建后的文件会存放在app\Providers\目录下</p><p><img src="https://upload.cc/i1/2018/10/27/dwBpYz.png" alt="avatar"></p><p>&emsp; 现在我们的服务已经在yourServiceProvider这个类里面的register()里面进行绑定了。虽然完成了服务提供者的创建和绑定，但框架现在不知道多了一个服务提供者，所以在程序运行过程中还不会调用该类中的registe()方法，所以需要在某个位置进行注册来告诉框架新创建的服务提供者–<strong>配置文件config\app.php</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'providers'</span> =&gt; [</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Laravel Framework Service Providers...</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Illuminate\Auth\AuthServiceProvider::class,</span><br><span class="line">    Illuminate\Broadcasting\BroadcastServiceProvider::class,</span><br><span class="line">    Illuminate\Bus\BusServiceProvider::class,</span><br><span class="line">    Illuminate\Cache\CacheServiceProvider::class,</span><br><span class="line">    Illuminate\Foundation\Providers\ConsoleSupportServiceProvider::class,</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    App\Providers\AppServiceProvider::class,</span><br><span class="line">    App\Providers\AuthServiceProvider::class,</span><br><span class="line">    <span class="comment">// App\Providers\BroadcastServiceProvider::class,</span></span><br><span class="line">    App\Providers\EventServiceProvider::class,</span><br><span class="line">    App\Providers\RouteServiceProvider::class,</span><br><span class="line"></span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>当laravel找到这个服务提供者的类以后，就会初始化这个服务提供者类，得到一个服务提供者的对象，然后调用它的register方法，自然它里面的所有服务绑定代码就都会执行了:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">registerConfiguredProviders</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $manifestPath = <span class="keyword">$this</span>-&gt;getCachedServicesPath();</span><br><span class="line"></span><br><span class="line">        (<span class="keyword">new</span> ProviderRepository(<span class="keyword">$this</span>, <span class="keyword">new</span> Filesystem, $manifestPath))</span><br><span class="line">                    -&gt;load(<span class="keyword">$this</span>-&gt;config[<span class="string">'app.providers'</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>laravel会把所有的自定义服务提供者都注册进来。这个注册的过程其实就是前面说的实例化服务提供者的类，并调用register方法的过程。</p><p>&emsp; 除了register方法，服务提供者里面还有一个boot方法，这个boot方法，会在所有的服务提供者都注册完成之后才会执行，所以当你想在服务绑定完成之后，通过容器解析出其它服务，做一些初始化工作的时候，那么就可以这些逻辑写在boot方法里面。因为boot方法执行的时候，所有服务提供者都已经被注册完毕了，所以在boot方法里面能够确保其它服务都能被解析出来。</p><p>&emsp; 以上主要介绍了laravel服务提供器的作用和具体使用方法，在我们平时的开发一般情况下引入第三方包就是这样的步骤（举例overtrue/laravel-wechat）： </p><ul><li>安装引入：composer require “overtrue/laravel-wechat:~4.0”</li><li><p>在 config/app.php 注册 ServiceProvider 和 Facade（Laravel 5.5 无需手动注册）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'providers'</span> =&gt; [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Overtrue\LaravelWeChat\ServiceProvider::class,</span><br><span class="line">],</span><br><span class="line"><span class="string">'aliases'</span> =&gt; [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">'EasyWeChat'</span> =&gt; Overtrue\LaravelWeChat\Facade::class,</span><br><span class="line">],</span><br></pre></td></tr></table></figure></li><li><p>创建配置文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">artisan vendor:publish --provider=<span class="string">"Overtrue\LaravelWeChat\ServiceProvider</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>服务提供者还有一个小问题值的注意，由于php是一门基本语言，在处理请求的时候，都会从入口文件把所有php都执行一遍。为了性能考虑，laravel会在第一次初始化的时候，把所有的服务提供者都缓存到bootstrap/cache/services.php文件里面，所以有时候当你改了一个服务提供者的代码以后，再刷新不一定能看到期望的效果，这有可能就是因为缓存所致。这时把services.php删掉就能看到你要的效果了。</p></blockquote><p>&emsp;再次感 云诸葛这篇文章，看完后收货很大，本文内容较为粗略，想要详细了解可以看这里<a href="https://www.cnblogs.com/lyzg/p/6181055.html#_label2" target="_blank" rel="noopener">laravel框架容器管理的一些要点</a></p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;emsp; 上一篇博客文章收集了关于Laravel服务容器的相关知识（&lt;a href=&quot;https://zgxxx.github.io/2018/10/14/20181013/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;），我们知道了服务容器主要有绑定和解析两个重要功能，那么Laravel这个框架集齐了如此多功能，我们项目可能还需要另外引入一些功能包，这些绑定必须有一个统一的管理工具，统一绑定在一个地方，这个地方就是服务提供者。&lt;/p&gt;
&lt;h2 id=&quot;关于服务提供者&quot;&gt;&lt;a href=&quot;#关于服务提供者&quot; class=&quot;headerlink&quot; title=&quot;关于服务提供者&quot;&gt;&lt;/a&gt;关于服务提供者&lt;/h2&gt;&lt;p&gt;&amp;emsp; 一开始学Laravel被服务容器和服务提供者两个名称搞混了，其实现在我是这样理解：容器就是底层一个大桶， 我们需要很多材料往里面填充，而提供者就是一些管道，我们就是通过提供者往容器里面塞我们需要的东西，需要的服务。&lt;/p&gt;
&lt;p&gt;&amp;emsp; Laravel有一种机制来定义和执行每个服务的初始处理，实现初始处理的类称为&lt;strong&gt;服务提供者&lt;/strong&gt;。 &lt;/p&gt;
&lt;p&gt;&amp;emsp; 服务提供者，在laravel里面，其实就是一个工厂类。它最大的作用就是用来进行服务绑定。当我们需要绑定一个或多个服务的时候，可以自定义一个服务提供者，然后把服务绑定的逻辑都放在该类的实现中。在larave里面，要自定一个服务提供者非常容易，只要继承Illuminate\Support\ServiceProvider这个类即可。下面通过一个简单的自定义服务提供者来说明服务提供者的一些要点：&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>假期结束</title>
    <link href="http://yoursite.com/2018/10/07/20181007/"/>
    <id>http://yoursite.com/2018/10/07/20181007/</id>
    <published>2018-10-07T13:06:54.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>假期结束，明天重新开始工作</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;假期结束，明天重新开始工作&lt;/p&gt;
&lt;script&gt;
var _hmt = _hmt || [];
(function() {
  var 
      
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yoursite.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>JWT -- JSON Web Token</title>
    <link href="http://yoursite.com/2018/09/25/20180925/"/>
    <id>http://yoursite.com/2018/09/25/20180925/</id>
    <published>2018-09-25T10:06:18.000Z</published>
    <updated>2019-01-18T13:05:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>做的项目一直都是用最经典session来实现用户认证，今天老大可能在重构H5模块发现session有问题，具体问题到时我再去看看。然后老大让我了解一下JWT,没听过这个东东，也是一脸懵逼，所以自己就在网上开始搜索相关知识，下面是一些网上找到的博客文章，进行收集整理，然后再添加自己的一些见解，具体的转载地址都在下面。</p><h2 id="传统session认证流程"><a href="#传统session认证流程" class="headerlink" title="传统session认证流程"></a>传统session认证流程</h2><ol><li>当用户使用用户名和密码登录之后, 服务器就会生成一个 session 文件, session 文件中保存着对这个用户的授权信息,这个文件可以储存在硬盘/内存/数据库中.</li><li>同时还要生成一个对应这个 session 文件的 <strong>sessionid</strong>, 通过 sessionid 就能够找到这个 session 文件.</li><li>然后将 sessionid 发送给客户端, 客户端就将 sessionid 保存起来, 保存的方式有很多种, 目前大多情况是通过 cookie 来保存 sessionid.</li><li>保存之后, 当客户机以后再向服务器发送请求的时候, 请求携带上 sessionid, 这样服务器收到 sessionid 之后,自己就会在服务区上查找对应的 session 文件, 如果查找成功, 就会得到该用户的授权信息, 从而完成一次授权.<a id="more"></a></li></ol><h2 id="session可能存在的问题"><a href="#session可能存在的问题" class="headerlink" title="session可能存在的问题"></a>session可能存在的问题</h2><ol><li>随着用户量的增加, 每个用户都需要在服务器上创建一个 session 文件, 这对服务器造成了压力；</li><li>对于服务器压力的分流问题, 如果一个用户的 session被存储在某台服务器上, 那么当这个用户访问服务器时,用户就只能在这台服务器上完成授权,其他的分流服务器无法进行对这种请求进行分流；</li><li>共享session 的问题, 当我们在一台服务器上成功登录, 如果我们想要另外的一台别的域名的服务器也能让用户不登录就能完成授权；</li><li>CSRF 攻击，通过非法的攻击代码，在用户不知情的情况下携带Cookie信息访问服务器，获取用户隐私信息</li></ol><h2 id="JWT原理"><a href="#JWT原理" class="headerlink" title="JWT原理"></a>JWT原理</h2><p>大致流程：</p><ol><li>客户端发送认证信息(一般就是用户名/密码), 向服务器发送请求；</li><li>服务器验证客户端的认证信息, 验证成功之后, 服务器向客户端返回一个加密的token(一般情况下就是一个字符串)；</li><li>客户端存储(cookie, session, app 中都可以存储)这个 token, 在之后每次向服务器发送请求时, 都携带上这个 token；</li><li>服务器验证这个 token 的合法性, 只要验证通过, 服务器就认为该请求是一个合法的请求</li></ol><p>其中服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;姓名&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;角色&quot;: &quot;管理员&quot;,</span><br><span class="line">  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h2 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h2><p>JWT实际上就是一个字符串，它由三部分组成，<strong>头部(Header)、载荷(Payload)与签名(Signature)</strong>。<br>形如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJmcm9tX3VzZXIiOiJCIiwidGFyZ2V0X3VzZXIiOiJBIn0.rSWamyAYwuHCo7IFAgd1oRpSP7nzL7BF5t7ItqpKViM</span><br></pre></td></tr></table></figure></p><h3 id="头部-Header"><a href="#头部-Header" class="headerlink" title="头部 Header"></a>头部 Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>alg</strong>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<strong>typ</strong>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>最后，将上面的 JSON 对象使用 Base64URL 算法（详见后文）转成字符串。</p><h3 id="载荷-Payload"><a href="#载荷-Payload" class="headerlink" title="载荷 Payload"></a>载荷 Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure></p><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，JWT 默认是不加密的，任何人都可以读到，所以<strong>不要把秘密信息放在这个部分</strong>。<br>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="签名-Signature"><a href="#签名-Signature" class="headerlink" title="签名 Signature"></a>签名 Signature</h3><p>Signature 部分是对前两部分的签名，<strong>防止数据篡改</strong>。<br>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure></p><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><h2 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h2><p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。<br>此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。<br><code>Authorization: Bearer &lt;token&gt;</code><br>另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。</p><h2 id="JWT-的几个特点"><a href="#JWT-的几个特点" class="headerlink" title="JWT 的几个特点"></a>JWT 的几个特点</h2><ol><li>JWT默认是不加密，但也是可以加密的。生成原始Token以后，可以用密钥再加密一次。</li><li>JWT不加密的情况下，不能将秘密数据写入JWT。</li><li>JWT不仅可以用于认证，也可以用于交换信息。有效使用JWT，可以降低服务器查询数据库的次数。</li><li>JWT的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦JWT签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</li><li>JWT本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用JWT的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li><li>为了减少盗用，JWT不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li></ol><p>以上就是对JWT资料的收集，有助于先对JWT有一个大概的认识和理解，后面公司项目版本迭代应该会用上JWT，到时会有实际操作，应该是使用支持laravel的一个插件–jwt-auth（<a href="https://laravel-china.org/articles/7264/using-jwt-auth-to-implement-api-user-authentication-and-painless-refresh-access-token" target="_blank" rel="noopener">Seaony：使用 Jwt-Auth 实现 API 用户认证以及无痛刷新访问令牌</a>）。</p><p>以上主要参考 </p><ul><li><a href="https://laravel-china.org/articles/6216/laravel-uses-jwt-to-implement-api-auth-to-build-user-authorization-interfaces" target="_blank" rel="noopener">Hexor：Laravel 使用 JWT 实现 API Auth, 打造用户授权接口</a></li><li>[阮一峰:JSON Web Token 入门教程][3]</li></ul><p>  <strong>[3]: <a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></strong></p>  <script>  var _hmt = _hmt || [];  (function() {    var hm = document.createElement("script");    hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";    var s = document.getElementsByTagName("script")[0];     s.parentNode.insertBefore(hm, s);  })();  </script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;做的项目一直都是用最经典session来实现用户认证，今天老大可能在重构H5模块发现session有问题，具体问题到时我再去看看。然后老大让我了解一下JWT,没听过这个东东，也是一脸懵逼，所以自己就在网上开始搜索相关知识，下面是一些网上找到的博客文章，进行收集整理，然后再添加自己的一些见解，具体的转载地址都在下面。&lt;/p&gt;
&lt;h2 id=&quot;传统session认证流程&quot;&gt;&lt;a href=&quot;#传统session认证流程&quot; class=&quot;headerlink&quot; title=&quot;传统session认证流程&quot;&gt;&lt;/a&gt;传统session认证流程&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;当用户使用用户名和密码登录之后, 服务器就会生成一个 session 文件, session 文件中保存着对这个用户的授权信息,这个文件可以储存在硬盘/内存/数据库中.&lt;/li&gt;
&lt;li&gt;同时还要生成一个对应这个 session 文件的 &lt;strong&gt;sessionid&lt;/strong&gt;, 通过 sessionid 就能够找到这个 session 文件.&lt;/li&gt;
&lt;li&gt;然后将 sessionid 发送给客户端, 客户端就将 sessionid 保存起来, 保存的方式有很多种, 目前大多情况是通过 cookie 来保存 sessionid.&lt;/li&gt;
&lt;li&gt;保存之后, 当客户机以后再向服务器发送请求的时候, 请求携带上 sessionid, 这样服务器收到 sessionid 之后,自己就会在服务区上查找对应的 session 文件, 如果查找成功, 就会得到该用户的授权信息, 从而完成一次授权.&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Web知识" scheme="http://yoursite.com/tags/Web%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>PHP之道-- 对象和引用</title>
    <link href="http://yoursite.com/2018/09/16/20180916-2/"/>
    <id>http://yoursite.com/2018/09/16/20180916-2/</id>
    <published>2018-09-16T15:56:23.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>在PHP 中引用的意思是用不同的名字访问同一个变量内容。与在C语言中的指针不同：例如不能对引用做指针运算，引用并不是实际的内存地址</p><p>PHP内核的角度：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct _zval_struct &#123;</span><br><span class="line">zvalue_value value; // 存储变量的值</span><br><span class="line">zend_uint refcount__gc; //表示引用计数 默认为：1</span><br><span class="line">zend_uchar type; // 变量具体的类型</span><br><span class="line">zend_uchar is_ref__gc; //表示是否为引用</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>举例：<br>$a = 10;<br>$b = $a;<br>这时$b没有引用，只是将$a的值赋给了$b，那么zval这个结构中的refcount__gc就变为2了，而is_ref__gc还是false,表示未引用，因为内核$a已经开辟了一块内存空间，当$a赋值给$b时，$b的值只指向了$a，这样就省去了重新开辟一块内存，但是当$b值被改变时($a的值不会变)，$b又将会开辟一块新的内存空间，这就是所谓的写时复制。下面就讲下引用：<br>$a = 10;<br>$b = &amp;$a;<br>这个时候，内核中存储$a的结构is_ref__gc标记为true，代表是引用，那么$a和$b都指向了同一个内存地址，当$b=20的时候，$a也会变成20</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &quot;ABC&quot;;</span><br><span class="line">$b = &amp;$a;</span><br><span class="line">echo $a;//这里输出:ABC</span><br><span class="line">echo $b;//这里输出:ABC</span><br><span class="line">$b= &quot;EFG&quot;;</span><br><span class="line">echo $a;//这里$a的值变为EFG 所以输出EFG</span><br><span class="line">echo $b;//这里输出EFG</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><h2 id="函数的传址调用"><a href="#函数的传址调用" class="headerlink" title="函数的传址调用:"></a>函数的传址调用:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function test(&amp;$a) &#123; 　　</span><br><span class="line">$a = $a+100;</span><br><span class="line">&#125;</span><br><span class="line">$b=1;</span><br><span class="line">echo $b;//输出１</span><br><span class="line">test($b); //这里$b传递给函数的其实是$b的变量内容所处的内存地址，通过在函数里改变$a的值　就可以改变$b的值了</span><br><span class="line">echo &quot;&lt;br&gt;&quot;;</span><br><span class="line">echo $b;//输出101</span><br></pre></td></tr></table></figure><h2 id="函数的引用返回"><a href="#函数的引用返回" class="headerlink" title="函数的引用返回:"></a>函数的引用返回:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function &amp;test() &#123;</span><br><span class="line">static $b = 0;//申明一个静态变量</span><br><span class="line">$b = $b + 1;</span><br><span class="line">echo $b;</span><br><span class="line">return $b;</span><br><span class="line">&#125;</span><br><span class="line">$a=test();//这条语句会输出　$b的值　为１</span><br><span class="line">$a=5;</span><br><span class="line">$a=test();//这条语句会输出　$b的值　为2</span><br><span class="line">$a=&amp;test();//这条语句会输出　$b的值　为3 $a=5;</span><br><span class="line">$a=test();//这条语句会输出　$b的值　为6</span><br></pre></td></tr></table></figure><p>通过$a=&amp;test(); 方式得到的才是函数的引用返回<br>$a=test()方式调用函数，只是将函数的值赋给$a而已，　而$a做任何改变　都不会影响到函数中的$b<br>而通过$a=&amp;test()方式调用函数呢, 他的作用是　将return $b中的　$b变量的内存地址与$a变量的内存地址　指向了同一个地方<br>即产生了相当于这样的效果($a=&b;) 所以改变$a的值　也同时改变了$b的值　所以在执行了<br>$a=&amp;test();<br>$a=5;<br>以后，$b的值变为了5 </p><h2 id="对象的调用"><a href="#对象的调用" class="headerlink" title="对象的调用"></a>对象的调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class a&#123;</span><br><span class="line">var $abc=&quot;ABC&quot;;</span><br><span class="line">&#125;</span><br><span class="line">$b=new a;</span><br><span class="line">$c=$b;</span><br><span class="line">echo $b-&gt;abc;//这里输出ABC</span><br><span class="line">echo $c-&gt;abc;//这里输出ABC</span><br><span class="line">$b-&gt;abc=&quot;DEF&quot;;</span><br><span class="line">echo $c-&gt;abc;//这里输出DEF</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>在PHP中，对象的复制是通过引用来实现的。<br>上列中$b=new a; $c=$b; 其实等效于$b=new a; $c=&amp;$b;</p><p>PHP中默认就是通过引用来调用对象， 但有时你可能想建立一个对象的副本，并希望原来的对象的改变不影响到副本。<br>为了这样的目的，PHP定义了一个特殊的方法，称为__clone.</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在PHP 中引用的意思是用不同的名字访问同一个变量内容。与在C语言中的指针不同：例如不能对引用做指针运算，引用并不是实际的内存地址&lt;/p&gt;
&lt;p&gt;PHP内核的角度：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;struct _zval_struct &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;zvalue_value value; // 存储变量的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;zend_uint refcount__gc; //表示引用计数 默认为：1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;zend_uchar type; // 变量具体的类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;zend_uchar is_ref__gc; //表示是否为引用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>PHP之道--《编程范式》篇</title>
    <link href="http://yoursite.com/2018/09/16/20180916/"/>
    <id>http://yoursite.com/2018/09/16/20180916/</id>
    <published>2018-09-16T15:50:01.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>PHP 5 支持抽象类和抽象方法。<strong>定义为抽象的类不能被实例化</strong>。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。</p><p><strong>继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。</strong>例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。<br><a id="more"></a><br>继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。<br>接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。</p><p>接口中定义的所有方法都必须是公有，这是接口的特性。<br>要实现一个接口，使用 implements 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。</p><p>Note:<br>实现多个接口时，接口中的方法不能有重名。</p><p>Note:接口也可以继承，通过使用 extends 操作符。</p><p>Note:类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。</p><p>Note:接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖。</p><h2 id="Trait（灵活）"><a href="#Trait（灵活）" class="headerlink" title="Trait（灵活）"></a>Trait（灵活）</h2><p>自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。</p><p>Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。Trait 和 Class 组合的语义定义了一种减少复杂性的方式，避免传统多继承和 Mixin 类相关典型问题。</p><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>PHP所提供的”重载”（overloading）是指动态地”创建”类属性和方法。我们是通过魔术方法（magic methods）来实现的。<br>所有的重载方法都必须被声明为 public。<br>Note:</p><p>这些魔术方法的参数都不能通过引用传递。</p><p>Note:</p><p>PHP中的”重载”与其它绝大多数面向对象语言不同。传统的”重载”是用于提供多个同名的类方法，但各方法的参数类型和个数不同。</p><p>在给不可访问属性赋值时，__set() 会被调用。</p><p>读取不可访问属性的值时，__get() 会被调用。</p><p>当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。</p><p>当对不可访问属性调用 unset() 时，__unset() 会被调用。</p><p>当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用</p><p>public  __call ( string $name , array $arguments )  (当调用不存在的方法时)</p><p>public static __callStatic ( string $name , array $arguments )  (对非静态方法使用静态调用时)</p><h2 id="动态调用函数"><a href="#动态调用函数" class="headerlink" title="动态调用函数"></a>动态调用函数</h2><p><strong>call_user_func</strong> 把第一个参数作为回调函数调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function increment(&amp;$var)</span><br><span class="line">&#123;</span><br><span class="line">    $var++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$a = 0;</span><br><span class="line">call_user_func(&apos;increment&apos;, $a);</span><br><span class="line">echo $a.&quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">call_user_func_array(&apos;increment&apos;, array(&amp;$a));</span><br><span class="line">echo $a.&quot;\n&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>输出</p><p>0</p><p>1</p><p><strong>call_user_func_array</strong> 调用回调函数，并把一个数组参数作为回调函数的参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function foobar($arg, $arg2) &#123;</span><br><span class="line">echo __FUNCTION__, &quot; got $arg and $arg2\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">class foo &#123;</span><br><span class="line">function bar($arg, $arg2) &#123;</span><br><span class="line">echo __METHOD__, &quot; got $arg and $arg2\n&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">call_user_func_array(&quot;foobar&quot;, array(&quot;one&quot;, &quot;two&quot;));</span><br><span class="line"></span><br><span class="line">$foo = new foo;</span><br><span class="line">call_user_func_array(array($foo, &quot;bar&quot;), array(&quot;three&quot;, &quot;four&quot;));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p><p>输出</p><p>foobar got one and two</p><p>foo::bar got three and four</p><p><code></code></p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;p&gt;PHP 5 支持抽象类和抽象方法。&lt;strong&gt;定义为抽象的类不能被实例化&lt;/strong&gt;。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。&lt;/strong&gt;例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>打造 Laravel 优美架构 谈可维护性与弹性设计</title>
    <link href="http://yoursite.com/2018/09/06/20180906/"/>
    <id>http://yoursite.com/2018/09/06/20180906/</id>
    <published>2018-09-06T15:10:32.000Z</published>
    <updated>2018-11-08T14:17:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>公司项目可能需要对架构进行重建，老大给了我一个视频让我学习里面的思想，看完后觉得收获很大，主讲人对laravel项目各个层次有很清晰的理解，力求做到职责单一分明，提高可维护性。下面是我看完视频对其内容的大概整理，以及一些自己的见解，有错误的请指出。<br>视频：<a href="https://www.youtube.com/watch?v=pzY0FBafXd0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=pzY0FBafXd0</a> (有墙各位懂的)</p><a id="more"></a><h2 id="Laravel简单架构："><a href="#Laravel简单架构：" class="headerlink" title="Laravel简单架构："></a>Laravel简单架构：</h2><p><img src="https://image-static.segmentfault.com/354/330/3543304019-5b90f9f1b87eb_articlex" alt="avarar"></p><p>简单的小项目可能会把数据库查询，业务逻辑，数据传给View几乎所有操作都放在Controller，如何项目后期需求变大，最后Controller会变得很臃肿，难懂，不易维护（同样，有些会把所有增删改查，功能类写在Model，Controller再从Model一个个的拿，导致Model很乱，Model有关联表的时候可能会引起一些不必要的数据库查询）</p><p>我自己的理解：用美宜佳卖商品给客人来理解，主要Controller是某个加盟商美宜佳门店，View是客人，Model是商品制造工厂（理解有些粗糙）</p><h2 id="Repository（商品仓库）"><a href="#Repository（商品仓库）" class="headerlink" title="Repository（商品仓库）:"></a>Repository（商品仓库）:</h2><p>跟Eloquent/DB操作相关的，例如增删改查，直接和数据库打交道的基础操作抽出来放在Repository中，repository中文是仓库，我的理解就是我们要从Model拿数据，先放在仓库repository中，统一由仓库管理分配，发挥仓库的职责<br><img src="https://image-static.segmentfault.com/182/683/1826836528-5b90fabebe585_articlex" alt="avarar"><br><img src="https://image-static.segmentfault.com/115/199/1151993428-5b90fad839146_articlex" alt="avarar"></p><h2 id="Service-总部服务平台"><a href="#Service-总部服务平台" class="headerlink" title="Service (总部服务平台):"></a>Service (总部服务平台):</h2><p>商业逻辑，不是简单的查询数据，而是特定的任务，例如判断用户是否是会员，设置用户权限等等，这些操作建议放在Service，之后Controller再调用它<br><img src="https://image-static.segmentfault.com/592/143/592143024-5b90fb1ea868e_articlex" alt="avarar"><br><img src="https://image-static.segmentfault.com/155/739/1557397158-5b90fb285edbf_articlex" alt="avarar"></p><p><strong>个人理解：</strong>所以在Controller和Model/Eloquent中间垫两层，如果Repository理解为商品仓库的话，我的理解Service是类似总部内部的服务平台，加盟商Controller需要拿商品给客人View，不能直接去食品工厂Model拿，先通过仓库repository，然后总部服务平台Service进行打包啊，整理啊，发车啊（各种任务），最后再给到加盟商Controller手里<br><img src="https://image-static.segmentfault.com/295/580/295580313-5b90fb0d82315_articlex" alt="avarar"></p><h2 id="Presenter（充值业务）"><a href="#Presenter（充值业务）" class="headerlink" title="Presenter（充值业务）:"></a>Presenter（充值业务）:</h2><p>一些比较固定，可以单独调用的，可以用Presenter抽出来，不需要让Model去做，下次修改也单独修改Presenter就行了，<br>例如时间戳转成Y-m-d H:i:s格式，可以单独用Presenter处理后用@inject插入到前端模板，而不是把转化过程写在模板上面<br><img src="https://image-static.segmentfault.com/710/831/710831743-5b90fb4eeb5ce_articlex" alt="avarar"><br><img src="https://image-static.segmentfault.com/256/257/2562576577-5b90fb61cbad4_articlex" alt="avarar"><br><img src="https://image-static.segmentfault.com/309/292/3092928320-5b90fb6f4b6f1_articlex" alt="avarar"><br><strong>个人理解：</strong>所以在Controller和View中间可以加一层Presenter，我的理解有点类似：美宜佳商户(Controller)可以给客人(View)充公交卡，这种小事不需要劳费工厂(Model)<br><img src="https://image-static.segmentfault.com/101/500/1015005224-5b90fb84bfc97_articlex" alt="avarar"></p><h2 id="Transformer（快餐小吃人工筛选）"><a href="#Transformer（快餐小吃人工筛选）" class="headerlink" title="Transformer（快餐小吃人工筛选）:"></a>Transformer（快餐小吃人工筛选）:</h2><p>转换器，例如在仓库repository中有一个获取所有用户信息的查询操作：$this-&gt;user-&gt;all();<br>但有些地方我们不需要用到那么多个字段，我只想有name和email字段，难道我要去改all()里面的参数，变成$this-&gt;user-&gt;all([‘name’,’email’])?<br>这样另外的地方又要全部字段，这不就冲突了？这时候Transformer就有用了，其实原理是对$this-&gt;user-&gt;all()获得的数据进行筛选后再输出，加了个筛选器。<br><img src="https://image-static.segmentfault.com/118/447/1184473386-5b90fb994f382_articlex" alt="avarar"><br><img src="https://image-static.segmentfault.com/337/359/3373598994-5b90fbad466dd_articlex" alt="avarar"><br><img src="https://image-static.segmentfault.com/192/588/1925884062-5b90fbc15db6e_articlex" alt="avarar"><br>之后要修改结果字段就直接在transform修改即可，当然还可以额外添加需要的字段：array_set()<br><img src="https://image-static.segmentfault.com/344/587/3445871937-5b90fc29f1e19_articlex" alt="avarar"><br><strong>个人理解：</strong>这一块我的理解就是有些客人需要点一些快餐，例如美宜佳里面的车仔面呀，烤肠呀，在卖出商品的时候需要根据客人的需求对小吃进行筛选再卖出去，不可能客人指点要一个烤肠，你把店里全部小吃拿给他，让他自个去筛选，中间卖出去的时候需要Transformer进行筛选再给出商品<br><img src="https://image-static.segmentfault.com/640/163/640163195-5b90fc3dcd04d_articlex" alt="avarar"></p><h2 id="Formatter（包装）"><a href="#Formatter（包装）" class="headerlink" title="Formatter（包装）:"></a>Formatter（包装）:</h2><p>主要用于保持API返回格式的一致（使用方法和transform类似）：<br><img src="https://image-static.segmentfault.com/296/081/2960819929-5b90fc60bc1a6_articlex" alt="avarar"><br><img src="https://image-static.segmentfault.com/115/776/1157764437-5b90fc91c2cb4_articlex" alt="avarar"><br><img src="https://image-static.segmentfault.com/310/382/3103826051-5b90fd995ba08_articlex" alt="avarar"><br>个人理解：Formatter这一块我的理解就是商品包装，客人买东西，买小吃，你需要对商品先进行包装，当然这个包装肯定需要保持一致<br><img src="https://image-static.segmentfault.com/170/055/1700552165-5b90fdab2371e_articlex" alt="avarar"><br>以上便是我再看完视频后对其进行总结整理，当然理论的说的容易，实际操作起来还有很多未知的问题，还是需要后面继续研究学习。</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司项目可能需要对架构进行重建，老大给了我一个视频让我学习里面的思想，看完后觉得收获很大，主讲人对laravel项目各个层次有很清晰的理解，力求做到职责单一分明，提高可维护性。下面是我看完视频对其内容的大概整理，以及一些自己的见解，有错误的请指出。&lt;br&gt;视频：&lt;a href=&quot;https://www.youtube.com/watch?v=pzY0FBafXd0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.youtube.com/watch?v=pzY0FBafXd0&lt;/a&gt; (有墙各位懂的)&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="Web知识" scheme="http://yoursite.com/tags/Web%E7%9F%A5%E8%AF%86/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击与防御</title>
    <link href="http://yoursite.com/2018/09/05/20180905/"/>
    <id>http://yoursite.com/2018/09/05/20180905/</id>
    <published>2018-09-05T13:40:16.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>转载地址：<a href="https://blog.csdn.net/stpeace/article/details/53512283" target="_blank" rel="noopener">https://blog.csdn.net/stpeace/article/details/53512283</a></p><h4 id="CSRF概念"><a href="#CSRF概念" class="headerlink" title="CSRF概念"></a>CSRF概念</h4><p>CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web  A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。<br><a id="more"></a></p><h4 id="CSRF攻击攻击原理及过程如下："><a href="#CSRF攻击攻击原理及过程如下：" class="headerlink" title="CSRF攻击攻击原理及过程如下："></a>CSRF攻击攻击原理及过程如下：</h4><ol><li><p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p></li><li><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p></li><li><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p></li><li><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p></li><li><p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p></li></ol><h4 id="CSRF攻击实例"><a href="#CSRF攻击实例" class="headerlink" title="CSRF攻击实例"></a>CSRF攻击实例</h4><p>受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p><p>黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> 但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p><p>这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory&quot;" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory&quot;</a> ,并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。 </p><h4 id="CSRF漏洞检测："><a href="#CSRF漏洞检测：" class="headerlink" title="CSRF漏洞检测："></a>CSRF漏洞检测：</h4><p>检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p><p>随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。</p><p>以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。</p><h4 id="防御CSRF攻击："><a href="#防御CSRF攻击：" class="headerlink" title="防御CSRF攻击："></a>防御CSRF攻击：</h4><p>目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p><p>（1）验证 HTTP Referer 字段</p><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ，用户必须先登陆bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p><p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p><p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p><p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p><p>（2）在请求地址中添加 token 并验证</p><p> CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue</a> 。而对于 POST 请求来说，要在 form 的最后加上 <code>&lt;input type=&quot;hidden&quot; name=&quot;csrftoken&quot; value=&quot;tokenvalue&quot;/&gt;</code>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p><p> 该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><p>（3）在 HTTP 头中自定义属性并验证</p><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载地址：&lt;a href=&quot;https://blog.csdn.net/stpeace/article/details/53512283&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/stpeace/article/details/53512283&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;CSRF概念&quot;&gt;&lt;a href=&quot;#CSRF概念&quot; class=&quot;headerlink&quot; title=&quot;CSRF概念&quot;&gt;&lt;/a&gt;CSRF概念&lt;/h4&gt;&lt;p&gt;CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web  A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Web知识" scheme="http://yoursite.com/tags/Web%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 实现单用户登录</title>
    <link href="http://yoursite.com/2018/09/04/20180904/"/>
    <id>http://yoursite.com/2018/09/04/20180904/</id>
    <published>2018-09-04T12:16:40.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>需求：同一时间只能有一个人登录账号，后登录者会把前登录者顶下线<br>参考：<a href="https://laravel-china.org/articles/2929/laravel-single-user-login" target="_blank" rel="noopener">https://laravel-china.org/articles/2929/laravel-single-user-login</a><br>    　<a href="https://segmentfault.com/a/1190000007906164" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007906164</a></p><h4 id="关键思路：登录时制作一个token（根据id-ip-time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth-logout-重定向到登录页面"><a href="#关键思路：登录时制作一个token（根据id-ip-time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth-logout-重定向到登录页面" class="headerlink" title="关键思路：登录时制作一个token（根据id,ip,time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth::logout(),重定向到登录页面"></a>关键思路：登录时制作一个token（根据id,ip,time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth::logout(),重定向到登录页面</h4><p>(原本参考laravel-china的文章使用响应后面添加withCookie来存token，后面想到cookie在浏览器关闭后会被删除，于是使用session)<br><a id="more"></a></p><h3 id="关键代码："><a href="#关键代码：" class="headerlink" title="关键代码："></a>关键代码：</h3><p>在登录事件监听handle写一个制作发送token的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public function handle(LoginEvent $event) &#123;</span><br><span class="line">    $this-&gt;sendCookieToken($member, $request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 制作token,用于单用户登录验证</span><br><span class="line"> */</span><br><span class="line">public function sendCookieToken(Authenticatable $member, Request $request) &#123;</span><br><span class="line">    $time = time();</span><br><span class="line">    $sinleToken = md5($request-&gt;getClientIp().$member-&gt;id.$time);</span><br><span class="line">    \Redis::set($member-&gt;id, $time);</span><br><span class="line">    $request-&gt;session()-&gt;put(&apos;SINGLETOKEN&apos;, $sinleToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>检查登录中间件进行验证：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">public function handle($request, Closure $next, $guard = null) &#123;</span><br><span class="line">   </span><br><span class="line">     if (!Auth::guard(&apos;web&apos;)-&gt;check()) &#123;</span><br><span class="line">          if ($request-&gt;ajax() || $request-&gt;header(&apos;ajax&apos;) == 1) &#123;</span><br><span class="line">             $return = [</span><br><span class="line">                &apos;code&apos; =&gt; ResultCode::CODE_NOT_LOGIN,</span><br><span class="line">                &apos;message&apos; =&gt; &apos;请登录!&apos;,</span><br><span class="line">                &apos;extra&apos; =&gt; [],</span><br><span class="line">                ];</span><br><span class="line">                return response()-&gt;json($return);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">                return redirect(&apos;/login&apos;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if ($this-&gt;isRelogin($request)) &#123;</span><br><span class="line">          \Auth::guard(&apos;web&apos;)-&gt;logout();</span><br><span class="line">          return redirect(&apos;/login&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">   </span><br><span class="line">    return $next($request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 比较token,判断是否需要重新登录</span><br><span class="line"> */</span><br><span class="line">protected function isRelogin($request) &#123;</span><br><span class="line">    $member = Auth::user();</span><br><span class="line">    if ($member) &#123;</span><br><span class="line">        // 获取 session 中的 token</span><br><span class="line">        $singletoken = $request-&gt;session()-&gt;get(&apos;SINGLETOKEN&apos;);</span><br><span class="line">        if ($singletoken) &#123;</span><br><span class="line">            // 从 redis 获取 time</span><br><span class="line">            $redisTime = \Redis::get($member-&gt;id);</span><br><span class="line">            // 重新获取加密参数加密</span><br><span class="line">            $ip = $request-&gt;getClientIp();</span><br><span class="line">            $secret = md5($ip . $member-&gt;id . $redisTime);</span><br><span class="line">            if ($singletoken !== $secret) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然路由还需根据自己项目来设置</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需求：同一时间只能有一个人登录账号，后登录者会把前登录者顶下线&lt;br&gt;参考：&lt;a href=&quot;https://laravel-china.org/articles/2929/laravel-single-user-login&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://laravel-china.org/articles/2929/laravel-single-user-login&lt;/a&gt;&lt;br&gt;    　&lt;a href=&quot;https://segmentfault.com/a/1190000007906164&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://segmentfault.com/a/1190000007906164&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;关键思路：登录时制作一个token（根据id-ip-time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth-logout-重定向到登录页面&quot;&gt;&lt;a href=&quot;#关键思路：登录时制作一个token（根据id-ip-time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth-logout-重定向到登录页面&quot; class=&quot;headerlink&quot; title=&quot;关键思路：登录时制作一个token（根据id,ip,time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth::logout(),重定向到登录页面&quot;&gt;&lt;/a&gt;关键思路：登录时制作一个token（根据id,ip,time），保存在session和redis中，在检查登录的中间件加一个token检验，如果token对不上说明有第二个人在另一个地方登录导致token被改变了，旧的登录者auth::logout(),重定向到登录页面&lt;/h4&gt;&lt;p&gt;(原本参考laravel-china的文章使用响应后面添加withCookie来存token，后面想到cookie在浏览器关闭后会被删除，于是使用session)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="Laravel" scheme="http://yoursite.com/tags/Laravel/"/>
    
  </entry>
  
  <entry>
    <title>Nginx与PHP的交互</title>
    <link href="http://yoursite.com/2018/09/02/20180902/"/>
    <id>http://yoursite.com/2018/09/02/20180902/</id>
    <published>2018-09-02T09:30:15.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Nginx是俄国人最早开发的Webserver，现已风靡全球，基本上LNMP成了当下的标配，下面主要根据网上收集的资料，对Nginx如何与php完成交互进行介绍。</p><a id="more"></a><h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h3><p>nginx server简单配置<br><img src="http://img0.ph.126.net/gI0rSwr7I-Sf8BXX1fqQ1Q==/6597835026751908513.png" alt="avatar"></p><p>nginx配置中注意到有fastcgi* 开头的配置，以及include引入的fastcgi.conf文件，这个文件也是有一堆fastcgi开头的配置项，这些配置项基本不改变，单独用.conf文件保存，可在多处引用<br><img src="http://img2.ph.126.net/NgIDW3ZKuD1mq4rayNWt7Q==/1401745384119579089.png" alt="avatar"></p><p>通常我们都知道了Nginx与PHP打交道主要就是FastCGI，下面来了解什么事FastCGI,它与Nginx和PHP有什么关系。</p><p>CGI是通用网关协议，FastCGI则是一种常住进程的CGI模式程序。我们所熟知的PHP-FPM的全称是PHP FastCGI Process Manager，即PHP-FPM会通过用户配置来管理一批FastCGI进程，例如在PHP-FPM管理下的某个FastCGI进程挂了，PHP-FPM会根据用户配置来看是否要重启补全，PHP-FPM更像是管理器，而真正衔接Nginx与PHP的则是FastCGI进程。（下图，FastCGI在请求流中的位置）<br><img src="http://img1.ph.126.net/BT2EVYWLQvuxzvVZN90DAA==/6632659858537940503.png" alt="avatar"><br>如上图所示，FastCGI的下游，是CGI-APP，在我们的LNMP架构里，这个CGI-APP就是PHP程序。而FastCGI的上游是Nginx，他们之间有一个通信载体，即图中的socket。在我们上文图的配置文件中，fastcgi_pass所配置的内容，便是告诉Nginx你接收到用户请求以后，你该往哪里转发，在我们图中是转发到本机的一个socket文件，这里fastcgi_pass也常配置为一个http接口地址（这个可以在php-fpm.conf中配置）。而上图中的Pre-fork，则对应着我们PHP-FPM的启动，也就是在我们启动PHP-FPM时便会根据用户配置启动诸多FastCGI触发器（FastCGI Wrapper）。</p><p>对FastCGI在Nginx+PHP的模式中的定位有了一定了解后，我们再来了解下Nginx中为何能写很多fastcgi_*的配置项。这是因为Nginx的一个默认内置module实现了FastCGI的Client。<br><img src="http://img2.ph.126.net/UYgvoyQNdW3y23hIxu_phg==/6632677450723985162.png" alt="avatar"><br>从图中可以看到，fastcgi_param所声明的内容，将会被传递给“FastCGI server”，那这里指的就是fastcgi_pass所指向的server，也就是我们Nginx+PHP模式下的PHP-FPM所管理的FastCGI进程，或者说是那个socket文件载体。这时，有的同学会问：“为什么PHP-FPM管理的那些FastCGI进程要关心这些参数呢？”，好问题，我们一起想想我们做PHP应用开发时候有没有用到$_SERVER这个全局变量，它里面包含了很多服务器的信息，比如包含了用户的IP地址。同学们不想想我们的PHP身处socket文件之后，为什么能得到远端用户的IP呢？上图中的一个fastcgi_param配置REMOTE_ADDR这不正是我们在PHP中用$_SERVER[‘REMOTE_ADDR’]取到的用户IP么。的确，Nginx这个模块里fastcgi_param参数，就是考虑后端程序有时需要获取Webserver外部的变量以及服务器情况。</p><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>Nginx+PHP的工程模式下，两位主角分工明确，Nginx负责承载HTTP请求的响应与返回，以及超时控制记录日志等HTTP相关的功能，而PHP则负责处理具体请求要做的业务逻辑，它们俩的这种合作模式也是常见的分层架构设计中的一种，在它们各有专注面的同时，FastCGI又很好的将两块衔接，保障上下游通信交互，这种通过某种协议或规范来衔接好上下游的模式，在我们日常的PHP应用开发中也有这样的思想落地，譬如我们所开发的高性能API，具体的Client到底是PC、APP还是某个其他程序，我们不关心，而这些PC、APP、第三方程序也不关心我们的PHP代码实现，他们按照API的规范来请求做处理即可</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;Nginx是俄国人最早开发的Webserver，现已风靡全球，基本上LNMP成了当下的标配，下面主要根据网上收集的资料，对Nginx如何与php完成交互进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="学习收集" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E6%94%B6%E9%9B%86/"/>
    
    
      <category term="辅助工具" scheme="http://yoursite.com/tags/%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7/"/>
    
      <category term="Web知识" scheme="http://yoursite.com/tags/Web%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>phpcs插件规范代码</title>
    <link href="http://yoursite.com/2018/08/13/20180813/"/>
    <id>http://yoursite.com/2018/08/13/20180813/</id>
    <published>2018-08-13T02:01:20.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>正式步入编程应该有1年多了，需要学习的还有数不尽的知识点。代码规范，在工作前我写的代码不多，也不规范不整洁，来到公司第一件事就是看手册，规范手册：<a href="http://docs.r9it.com/manual/php/" target="_blank" rel="noopener">http://docs.r9it.com/manual/php/</a> 但平时习惯一时改不过来，在Laravel China社区看见一篇文章介绍phpcs 插件，能够辅助和实时提醒我们的代码规范性</p><p>Github安装<br>地址：<a href="https://github.com/squizlabs/PHP_CodeSniffer" target="_blank" rel="noopener">https://github.com/squizlabs/PHP_CodeSniffer</a><br>似乎Composer安装时最方便的，我是跟着<a href="https://laravel-china.org/articles/13006/recommend-a-phpcs-plug-in-to-standardize-laravel-code-specification-from-local-code-to-version-control" target="_blank" rel="noopener">https://laravel-china.org/articles/13006/recommend-a-phpcs-plug-in-to-standardize-laravel-code-specification-from-local-code-to-version-control</a><br> 这篇文章来安装操作的<br><a id="more"></a><br><img src="http://img1.ph.126.net/JTZdDTHxb8DgtU7OK9OLbQ==/761389812102929773.png" alt="avatar"></p><p>其中有个坑，在安装pear的时候老是安装不进去，<br><code>Unable to create PHP code directory ($php_dir) /usr/local/pear/share/pear. Run...</code><br>类似这样的错误，其实就是 /usr/local这个文件夹没权限，给777就ok了</p><p><img src="http://ow20g4tgj.bkt.clouddn.com/2018-06-04-15281051135875.jpg" alt="avatar"><br><img src="http://ow20g4tgj.bkt.clouddn.com/2018-06-04-15281051693608.jpg" alt="avatar"><br><img src="http://ow20g4tgj.bkt.clouddn.com/2018-06-04-15281052220415.jpg" alt="avatar"><br><img src="http://ow20g4tgj.bkt.clouddn.com/2018-06-04-15281050422097.jpg" alt="avatar"><br><img src="http://ow20g4tgj.bkt.clouddn.com/2018-06-04-15281049945425.jpg" alt="avatar"></p><p>这样就能在phpstorm里面自动提示规范问题了。</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;正式步入编程应该有1年多了，需要学习的还有数不尽的知识点。代码规范，在工作前我写的代码不多，也不规范不整洁，来到公司第一件事就是看手册，规范手册：&lt;a href=&quot;http://docs.r9it.com/manual/php/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://docs.r9it.com/manual/php/&lt;/a&gt; 但平时习惯一时改不过来，在Laravel China社区看见一篇文章介绍phpcs 插件，能够辅助和实时提醒我们的代码规范性&lt;/p&gt;
&lt;p&gt;Github安装&lt;br&gt;地址：&lt;a href=&quot;https://github.com/squizlabs/PHP_CodeSniffer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/squizlabs/PHP_CodeSniffer&lt;/a&gt;&lt;br&gt;似乎Composer安装时最方便的，我是跟着&lt;a href=&quot;https://laravel-china.org/articles/13006/recommend-a-phpcs-plug-in-to-standardize-laravel-code-specification-from-local-code-to-version-control&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://laravel-china.org/articles/13006/recommend-a-phpcs-plug-in-to-standardize-laravel-code-specification-from-local-code-to-version-control&lt;/a&gt;&lt;br&gt; 这篇文章来安装操作的&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="PHP" scheme="http://yoursite.com/categories/PHP/"/>
    
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
      <category term="PHP" scheme="http://yoursite.com/tags/PHP/"/>
    
      <category term="PHP工具" scheme="http://yoursite.com/tags/PHP%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>手残sudo -R 777 /etc(/usr)后怎么办</title>
    <link href="http://yoursite.com/2018/08/12/20180812/"/>
    <id>http://yoursite.com/2018/08/12/20180812/</id>
    <published>2018-08-12T07:55:02.000Z</published>
    <updated>2018-11-08T12:21:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>再也不敢随便给权限，更加不能随便-R了<br>执行<code>sudo -R 777 /etc(/usr)</code>后sudo就不能使用了，会出现错误：<code>sudo: /usr/bin/sudo must be owned by uid 0 and have the setuid bit set</code><br>（sudo: /usr/bin/sudo 必须属于用户 ID 0(的用户)并且设置 setuid 位）</p><p>填坑过程：百度+Google<br>首先重启系统，按esc进入Ubuntu<br>grub菜单（系统不同进入方法不同），反正找到recovery mode，选择root，回车进入命令行输入<code>：mount -o remount,rw /</code>（重新挂载，让我/路径文件系统为可读可写模式）</p><pre><code>chown root:root /usr/bin/sudochmod 4755 /usr/bin/sudo</code></pre><p>reboot重新开机后sudo出现另一个错误：</p><pre><code>sudo: error in /etc/sudo.conf, line 0 while loading plugin &apos;sudoers_policy&apos;sudo: /usr/lib/sudo/sudoers.so must only be writable by ownersudo: fatal error, unable to load plugins</code></pre><p>解决：(依然需要进入recovery)</p><pre><code>$ chmod 644 /usr/lib/sudo/sudoers.so$ chown -R root /usr/lib/sudo</code></pre><p>不知道啥原理，但是感谢<a href="https://blog.csdn.net/lileihappy/article/details/79214156提供的参考" target="_blank" rel="noopener">https://blog.csdn.net/lileihappy/article/details/79214156提供的参考</a><br>(吐槽下百度有些答案:<br>    Ctrl+Alt+F1进入窗口模式<br>    sudo -s(sudo都不能用了还来这个)<br>    chown root:root /usr/bin/sudo<br>    chmod 4755 /usr/bin/sudo<br>    reboot<br>)</p><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?efa3a0b3e4ba396962eddb7275e07e31";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);})();</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;再也不敢随便给权限，更加不能随便-R了&lt;br&gt;执行&lt;code&gt;sudo -R 777 /etc(/usr)&lt;/code&gt;后sudo就不能使用了，会出现错误：&lt;code&gt;sudo: /usr/bin/sudo must be owned by uid 0 and have t
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="踩坑" scheme="http://yoursite.com/tags/%E8%B8%A9%E5%9D%91/"/>
    
  </entry>
  
</feed>
